# 处理数据
在处理事务和DBAPI时，我们学习了如何与Python DBAPI及其事务状态进行交互的基础知识。然后，在处理数据库元数据时，我们学习了如何使用 SQLAlchemy 中的 MetaData 和相关对象来表示数据库表、列和约束。
在本节中，我们将结合上述两个概念来创建、选择和操作关系数据库中的数据。我们与数据库的交互始终是在事务的范围内，即使我们已经将数据库驱动程序设置为在后台使用自动提交。

本节的组成部分如下：
+ 使用INSERT语句，将一些数据放入数据库中，这里先使用Core来演示，ORM在下一节
+ 使用SELECT语句，本节将详细描述 Select 构造，这是 SQLAlchemy 中最常用的对象。 Select 构造会为 Core 和 ORM 中心应用程序发出 SELECT 语句，并且这两种用例将在此处描述
+ 使用 UPDATE 和 DELETE 语句 - 本节将从Core角度描述 Update 和 Delete 构造的使用，以补充数据的插入和选择。

## 使用INSERT语句
在使用Core时以及在使用ORM进行批量操作的时候，将直接使用insert()函数来生成SQL的INSERT语句，这个函数生成一个Insert的新实例，表示SQL中的INSERT语句，将新数据添加到表中
> 写给ORM的读者  
> 这一节详细介绍了通过Core生成SQL INSERT语句的方法，以便向表中添加新的行。在使用ORM的时候，我们通常使用另一个工具，也就是基于Core上的工作单元，它将自动化一次生成多个 INSERT 语句。
> 即使ORM会为我们自动执行，了解Core如何处理数据创建和操作也是非常有用的。
> 此外，ORM 支持使用名为 Bulk / Multi Row INSERT、upsert、UPDATE 和 DELETE 的功能直接使用 INSERT。

### insert() SQL 表达式构造函
一个简单的示例 Insert ，同时说明目标表和 VALUES 子句：
```python
from sqlalchemy import insert
stmt = insert(user_table).values(name="spongebob", fullname="Spongebob Squarepants")
```
上述 stmt 变量是 Insert 的一个实例。大多数 SQL 表达式可以直接转换为字符串形式，以便查看生成的一般形式：
```python
print(stmt)
INSERT INTO user_account (name, fullname) VALUES (:name, :fullname)
```
字符串形式是通过生成一个 Compiled 对象的形式来创建的，该对象包括语句的特定于数据库的字符串 SQL 表示；我们可以直接使用 ClauseElement.compile() 方法获取此对象：
```python
compiled = stmt.compile()
```
我们的 Insert 构造是一个“参数化”构造的示例，之前在发送参数中已经说明；要查看 name 和 fullname 绑定的参数，这些也可以从 Compiled 构造中获得：
```python
compiled.params
{'name': 'spongebob', 'fullname': 'Spongebob Squarepants'}
```
### 执行语句
调用该语句，我们可以向 user_table 插入一行。插入 SQL 以及捆绑参数可以在 SQL 日志中看到：
```python
with engine.connect() as conn:
    result = conn.execute(stmt)
    conn.commit()

BEGIN (implicit)
INSERT INTO user_account (name, fullname) VALUES (?, ?)
[...] ('spongebob', 'Spongebob Squarepants')
COMMIT
```
在上面的简单形式中，INSERT 语句不会返回任何行，如果只插入了一行，通常会包括返回有关在插入该行期间生成的列级默认值信息的能力，最常见的是整数主键值。
在上述情况下，SQLite 数据库中的第一行通常会返回 1 作为第一个整数主键值，我们可以使用 CursorResult.inserted_primary_key 访问器获取该值：
```python
result.inserted_primary_key
(1,)
```
> Tip  
> CursorResult.inserted_primary_key 返回一个元组，因为主键可能包含多个列。这被称为复合主键。 CursorResult.inserted_primary_key 旨在始终包含刚刚插入记录的完整主键，而不仅仅是“cursor.lastrowid”类型的值，并且旨在填充，无论是否使用了“autoincrement”，因此为了表示完整的主键，它是一个元组。

> 从版本 1.4.8 开始更改： CursorResult.inserted_primary_key 返回的元组现在是一个命名元组，通过将其作为 Row 对象返回来实现。

### 通常，INSERT 会自动生成“values”子句
上面的示例使用Insert.values()方法显示地创建了SQL INSERT语句的VALUES子句。如果我们实际上不使用Insert.values()，只是打印出一个“空”语句，我们会为表中的每一个列得到一个INSERT:
```python
print(insert(user_table))
INSERT INTO user_account (id, name, fullname) VALUES (:id, :name, :fullname)
```
如果我们执行一个没有调用过Insert.values()方法的Insert构造，而不是打印它，该语句将根据我们传递给 Connection.execute() 方法的参数编译为一个字符串，并且只包括与传递的参数相关的列。这实际上是 Insert 通常用于插入行而无需输入显式 VALUES 子句的方法。下面的示例说明了一个包含两列的 INSERT 语句一次执行一个参数列表：
```python
with engine.connect() as conn:
    result = conn.execute(
        insert(user_table),
        [
            {"name": "sandy", "fullname": "Sandy Cheeks"},
            {"name": "patrick", "fullname": "Patrick Star"},
        ],
    )
    conn.commit()
```
上面的执行过程展示了“executemany”形式，但与使用 text() 结构时不同，我们不必拼写任何 SQL。通过将字典或字典列表传递给 Connection.execute() 方法，并与 Insert 结构一起使用， Connection 确保传递的列名将自动在 Insert 结构的 VALUES 子句中表达。
#### Deep Alchemy(高级用法)
在这里，我们会向address_table中添加一些有趣的数据。下面的例子是一个更高级的示例，说明了如何明确使用Insert.values()方法，同时包括从参数生成的额外值。构建了一个标量子查询，利用了下一节介绍的select()结构，并且子查询中使用的参数是使用明确的绑定参数名称设置的，使用了 bindparam() 结构建立。

这是一些稍微深入的炼金术，只是为了我们可以在不从 user_table 操作中提取主键标识符的情况下添加相关行到应用程序中。大多数炼金术士将简单地使用 ORM，它会为我们处理这样的事情。
```python
from sqlalchemy import select, bindparam
scalar_subq = (
    select(user_table.c.id)
    .where(user_table.c.name == bindparam("username"))
    .scalar_subquery()
)

with engine.connect() as conn:
    result = conn.execute(
        insert(address_table).values(user_id=scalar_subq),
        [
            {
                "username": "spongebob",
                "email_address": "spongebob@sqlalchemy.org",
            },
            {"username": "sandy", "email_address": "sandy@sqlalchemy.org"},
            {"username": "sandy", "email_address": "sandy@squirrelpower.org"},
        ],
    )
    conn.commit()
```
```python
BEGIN (implicit)
INSERT INTO address (user_id, email_address) VALUES ((SELECT user_account.id
FROM user_account
WHERE user_account.name = ?), ?)
[...] [('spongebob', 'spongebob@sqlalchemy.org'), ('sandy', 'sandy@sqlalchemy.org'),
('sandy', 'sandy@squirrelpower.org')]
COMMIT
```
有了这些，我们的表格中还有一些更有趣的数据，我们将在接下来的部分中加以利用。
> Tip  
> 一个真正的“空”INSERT，只插入表的“默认”值，而不包括任何显式值，如果我们指示 Insert.values() 没有参数，则会生成；并非每个数据库后端都支持这一点，但这是 SQLite 生成的内容
>
>```python
>print(insert(user_table).values().compile(engine))
>INSERT INTO user_account DEFAULT VALUES
>```
### INSERT...RETURNING
支持后端自动调用RETURNING子句，以检索最后插入的主键值及服务器默认值。但是，也可以使用Insert.returning()方法显式指定RETURNING子句；在这种情况下，当执行语句时返回的Result对象具有可获取的行
```python
insert_stmt = insert(address_table).returning(
    address_table.c.id, address_table.c.email_address
)
print(insert_stmt)

INSERT INTO address (id, user_id, email_address)
VALUES (:id, :user_id, :email_address)
RETURNING address.id, address.email_address
```
它也可以与 Insert.from_select() 结合使用，就像下面的示例一样，该示例是在 INSERT…FROM SELECT 中提到的示例的基础上构建的
```python
select_stmt = select(user_table.c.id, user_table.c.name + "@aol.com")
insert_stmt = insert(address_table).from_select(
    ["user_id", "email_address"], select_stmt
)
print(insert_stmt.returning(address_table.c.id, address_table.c.email_address))
```
> Tip  
> RETURNING 功能也受 UPDATE 和 DELETE 语句支持，这将在本教程后面介绍。  
> 对于 INSERT 语句，RETURNING 功能可以用于单行语句以及一次插入多行的语句。支持具有 RETURNING 的多行 INSERT 是方言特定的，但是对于所有支持 RETURNING 的 SQLAlchemy 中包含的方言都是支持的。

> See also  
> ORM 也支持带有或不带有 RETURNING 的批量插入。
### INSERT…FROM SELECT
Insert 的一个较少使用的功能，但为了完整起见， Insert 构造可以使用 Insert.from_select() 方法直接从 SELECT 获取行来组成 INSERT。该方法接受一个 select() 构造，将在下一节中讨论，以及一个要在实际 INSERT 中定位的列名列表。在下面的示例中，从 user_account 表中派生的行将添加到 address 表中，为每个用户提供一个在 aol.com 处的免费电子邮件地址：
```python
select_stmt = select(user_table.c.id, user_table.c.name + "@aol.com")
insert_stmt = insert(address_table).from_select(
    ["user_id", "email_address"], select_stmt
)
print(insert_stmt)

INSERT INTO address (user_id, email_address)
SELECT user_account.id, user_account.name || :name_1 AS anon_1
FROM user_account
```
此构造用于当一个人想要将数据从数据库的其他部分直接复制到一组新的行中，而不实际从客户端获取和重新发送数据时。

