#第5章 条件、循环及其他语句
## 5.1 再谈print和import
### 5.1.1打印多个参数
```python
# 可以打印多个参数，会用空格分开
print('Age', 42)  # Age 42

# 自定义分隔符
print("哇", "哈", "哈", sep="_") # 哇_哈_哈

# 自定义结束字符串，定义为！所以不会换行
print("fuck", "you", end='!')
print("ford") # 此处没有指定结尾符，所以是换行，haha将在下一行输出
print('haha')

# fuck you!ford
# haha
```
### 5.1.2 导入时重命名
```python
#导入模块的相关方式
import somemodule
from somemodule import somefunction
from somemodule import somedfunction, annotherfunction

# 只有要导入模块中的一切时，才采用最后一种方式
from somemodule import *

# 可以给模块和方法指定别名
import math as foobar
from math import  sqrt as foobar
```

## 5.2 赋值魔法
### 5.2.1 序列解包
序列解包:将一个序列（或任何可迭代对象）解包，并将得到的值存储到一系列变量里
```python
# 同时赋值
x, y, z = 1, 2, 3
print(x, y, z)
# 可以用来交换值
x, y = y, x
print(x, y, z)

values = 1, 2, 3
x, y, z = values
print(x)

# 和js里解构感觉很像，但是这里不要求名称必须对应
person = {"name": 'zjx', "girlfriend": 'ckx'}
key, value = person.popitem()
print(key, value) # girlfriend ckx
```
要保证要解包的序列包含的元素个数必须和等号左边变量的数量相同，否则会抛出异常  
用*来收集参数
```python
# 利用*来收集剩余参数
x, y, *z = [1, 2, 3, 4]
print(z)  # [3, 4]
# 也可以收集中间的参数
x, *y, z = [1, 2, 3, 4, 5]
print(y)  # [2, 3, 4]
# 即使收集到的参数数量为1，返回的也是一个列表
x, y, *z = [1, 2, 3]
print(x, y, z)  # 1 2 [3]
```

### 5.2.2 链式赋值
```python
x = y = 1
# 等同于
y = 1
x = y
```

### 5.2.3 增强赋值
适用于所有标准运算符，如*、/、%等
```python
x = 2
x += 1
x *= 2
print(x) # 6
```
增强赋值也可用于其他数据类型（只要使用的双目运算符可用于这些数据类型）
```python
fnord = 'foo'
fnord += 'bar'
fnord *= 2
print(fnord) # foobarfoobar
```
## 5.3 代码块
代码块是一组语句，可以在满足条件的时候执行（if），可以多次执行（for），等等。Python中，代码块通过缩进来实现。  
Python中使用`:`来表示接下来是一个代码块，并将该代码块中的每行代码都缩进相同的程度。
```python
# 示例
this is a line
this is another line:
    this is another block
    continuing the same block
    the last line of this block
phew, there we escaped the inner block
```

## 5.4 条件和条件语句
### 5.4.1 布尔值
Python中认为为假的值：False None 0 "" () [] {}  
各种类型的数值0，空序列，以及空映射都视为假，而其他各种值都视为真
```python
# 其实True和False就是0和1
print(True == 1) # True
print(False == 0) # True
print(True + False + 12)  # 13

# 可以利用bool函数转换其他值
bool("fuck") # True
bool(42) # True
bool('') #False
bool(0) #False
```

### 5.4.2---5.4.5if语句示例
```python
num = int(input(('Enter a number')))
if num > 0:
    print("The number is positive")
elif num < 0:
    print("The number is negative")
else:
    print("The number is zero")

```
```python
name = input("What's your name?")
if name.endswith('Gumby'):
    if name.startswith("Mr."):
        print('Hello, Mr.Gumby')
    elif name.startswith("Mrs."):
        print('Hello, Mrs. Gumby')
    else:
        print('Hello, Gumby')
else:
    print("Hello Stranger")

```
条件表达式，类似于一种简单的if else语句，可以简便得对变量进行判断
```python
name = 'zjx'
status = 'friend' if name.endswith('Gumby') else 'stranger'
```
### 5.4.6 更复杂的条件
1. 比较运算符   

|表达式|描述|
|:---:|:---:|
|x == y|x等于y|
|x < y|x小于y|
|x > y|x大于y|
|x <= y|x小于等于y|
|x >= y|x大于等于y|
|x != y|x不等于y|
|x is y|x和y是同一个对象|
|x is not y|x和y不是同一个对象|
|x in y|x是容器（例如序列）y的成员|
|x not in y|x不是容器（例如序列）y的成员|

+ `is` 和 `==`   
`is`来判断是否是相同的对象 `==`来判断值是否相等
```python
x = y = [1, 2, 3]
z = [1, 2, 3]
print(x == y) #True
print(x is y) #True
print(x == z) #True
print(x is z) #False
```
+ 字符串和序列的比较
字符串是根据字符的字母排列顺序进行比较的
```python
'alpha' < 'beta'
# True
```
虽然基于的是字母排列顺序，但字母都是Unicode字符，它们是按码点排列的。  
通过函数`ord`可以获取顺序值
```python
ord('赵') # 36213
```


2.布尔运算符 and or not  
> 布尔运算符只做必要的运算 x and y 只要x为false 那么立即返回false  
> 实际上，如果x为假，那么这个表达式将返回x，否则返回y
> 对于运算符or，情况亦如此。在表达式x or y中，如果x为真，就返回x，否则返回y。  
> 请注意，这意味着位于布尔运算符后面的代码（如函数调用）可能根本不会执行。  

### 5.4.7 断言
```python
age = -1
assert age > 0, 'The age must be realistic'
```

## 5.5 循环
### 5.5.1 while循环
```python
x = 1
while x <= 100:
    print(x)
    x += 1
```

### 5.5.2 for循环
```python
# 可以使用for循环遍历可迭代的对象
words = ['fuck', 'you', 'haha']
for w in words:
    print(w)

# 利用range()函数创建范围
print(list(range(0, 10)))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

for num in range(1, 101):
    print(num)
```

### 5.5.3 迭代字典
```python
# key.items()以元组的形式返回键值对，而且可以使用序列解包
d = {"x": 1, 'y': 2, 'z': 3}
for key, value in d.items():
    print(key, "对应的value是", value)

for key in d:
    print(key, '对应的值', d[key])
```
> 字典里元素的排列顺序是不确定的。如果顺序很重要的话，可以将key或者value存储在一个列表里，再
> 将列表排序，之后再迭代。
> 要让映射记住项的插入顺序，可以使用collections模块里的OrderedDict类
### 5.5.4 一些迭代工具
1. 并行迭代
```python
# 使用zip函数 缝合两个序列 返回一个由元组组成的序列
# 如果长度不同，将取更短者的长度
names = ['anne', 'beth', 'george', 'damon']
ages = [12, 45, 32, 102]
# 将返回一个由元组组成的list  [('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
newList = list(zip(names, ages))
for name, age in newList:
    print('名字是', name, '年龄', age)
```
2. 迭代时获取索引
```python
strings = ['a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1']
for index, string in enumerate(strings):
    if 'c' in string:
        strings[index] = '哈'
```
3. 反向迭代和排序后再迭代  

reversed和sorted函数可以用于任何序列或可迭代的对象，而且不是就地修改，而是返回一个新的。
```python
print(sorted([4, 3, 5, 8, 2]))  # [2, 3, 4, 5, 8]
print(sorted('hello,world'))  # [',', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']

print(list(reversed('Hello, world!')))  # ['!', 'd', 'l', 'r', 'o', 'w', ' ', ',', 'o', 'l', 'l', 'e', 'H']
# reversed返回的不是一个列表，而是一个可迭代对象
print(reversed('Hello, world!'))  # <reversed object at 0x10c6ab430>
print(''.join(reversed('Hello, world!')))  # !dlrow ,olleH
```

### 5.5.5 跳出循环

break 用来跳出循环
```python
from math import sqrt

# 从99开始以步长为-1迭代,找到小于100的最大平方值（乘数与自己相乘的结果）
for n in range(99, 0, -1):
    root = sqrt(n)
    print(root)
    if root == int(root):
        print(n)
        break
```


continue用来跳出当前循环开始下次循环
```python
for x in seq:
    if condition1: continue 
    if condition2: continue 
    if condition3: continue

do_something() 
do_something_else() 
do_another_thing() 
etc()
```

while True/break结合使用
```python
while True:
    word = input('please input a word')
    if not word:
        break
    print('the word is', word)
```

###5.5.6 循环中的 else 子句
循环中的else语句 它仅在没有调用break时才执行
```python
for n in range(99, 81, -1):
    root = sqrt(n)
    if root == int(root):
        print(n)
        break
else:
    print("Didn't find it")
```

## 5.6 简单推导 列表推导式
```python
# 生成从0到9的平方组成的列表
print([x * x for x in range(10)])  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 打印那些能被3整除的平方值
print([x * x for x in range(10) if x % 3 == 0])  # [0, 9, 36, 81]

print([(x, y) for x in range(3) for y in range(3)])
# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

列表推导式示例
```python
# 将girls和boys的首字母配对
girls = ['alice', 'bernice', 'clarice']
boys = ['chris', 'arnold', 'bob']
print([b + "+" + g for b in boys for g in girls if b[0] == g[0]])
# ['chris+clarice', 'arnold+alice', 'bob+bernice']

# 更好的解法
letterGirls = {}
for girl in girls:
    # 建立字典，key为首字母，value默认为[]，之后添加girl全名
    letterGirls.setdefault(girl[0], []).append(girl)
    print("输出每次的letterGirls", letterGirls)
print([b + "+" + g for b in boys for g in letterGirls[b[0]]])
```
使用圆括号并不能实现元组推导，而是创建生成器  
然而可以使用花括号执行字典推导
```python
squares = {i: "{} squared is {}".format(i, i ** 2) for i in range(10)}
print(squares[8])
```
## 5.7 pass del 和exec
###5.7.1 什么都不做 
pass可以用作占位符，表示什么都不做
```python
if name == 'Ralph Auldus Melish':
    print('Welcome')
elif name == 'Enid':
    # 还未完成
    pass
elif name == 'Bill Gates':
    print('Access Denied')
```

### 5.7.2 使用 del 删除
```python
dit1 = {'x': 1, 'y': 2}
dit2 = dit1
dit1 = None
dit2 = None
# Python解释器将进行垃圾回收 因为没有对象引用它了

x = 1
del x
# print(x)
#NameError: name 'x' is not defined
```

### 5.7.3 使用 exec 和 eval 执行字符串及计算其结果

exec
```python
exec("print('hello world')")
# 执行的同时传入命名空间防止污染其他代码,exec执行的结果将保存在scope里
from math import sqrt
scope = {}
exec("sqrt = 1", scope)
print(sqrt(4))
```

eval
```python
#eval计算用字符串表示的Python表达式的值，并返回结果（exec什么都不返回，因为它本身是条语句）。
print(eval(input("请输入表达式")))
#也可以提供命名空间
```

# 5.8 小结
+ 打印语句：你可使用print语句来打印多个用逗号分隔的值。如果print语句以逗号结尾，
后续print语句将在当前行接着打印。
+ 导入语句：有时候，你不喜欢要导入的函数的名称——可能是因为你已将这个名称用作
他用。在这种情况下，可使用import ... as ...语句在本地重命名函数。
+ 赋值语句：通过使用奇妙的序列解包和链式赋值，可同时给多个变量赋值；而通过使用
增强赋值，可就地修改变量。
+ 代码块：代码块用于通过缩进将语句编组。代码块可用于条件语句和循环中，还可用于
函数和类定义中（这将在本书后面介绍）。
+ 条件语句：条件语句根据条件（布尔表达式）决定是否执行后续代码块。通过使用if/elif/
else，可将多个条件语句组合起来。条件语句的一个变种是条件表达式，如a if b else c。
+ 断言：断言断定某件事（一个布尔表达式）为真，可包含说明为何必须如此的字符串。
如果指定的表达式为假，断言将导致程序停止执行（或引发第8章将介绍的异常）。最好
尽早将错误揪出来，免得它潜藏在程序中，直到带来麻烦。
+ 循环：你可针对序列中的每个元素（如特定范围内的每个数）执行代码块，也可在条件
为真时反复执行代码块。要跳过代码块中余下的代码，直接进入下一次迭代，可使用
continue语句；要跳出循环，可使用break语句。另外，你还可在循环末尾添加一个else
子句，它将在没有执行循环中的任何break语句时执行。
+ 推导：推导并不是语句，而是表达式。它们看起来很像循环，因此我将它们放在循环中
讨论。通过列表推导，可从既有列表创建出新列表，这是通过对列表元素调用函数、剔
除不想要的函数等实现的。推导功能强大，但在很多情况下，使用普通循环和条件语句
也可完成任务，且代码的可读性可能更高。使用类似于列表推导的表达式可创建出字典。
+ pass、 del、 exec和eval： pass语句什么都不做，但适合用作占位符。 del语句用于删除变
量或数据结构的成员，但不能用于删除值。函数exec用于将字符串作为Python程序执行。
函数eval计算用字符串表示的表达式并返回结果。