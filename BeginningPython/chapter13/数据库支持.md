#第13章 数据库支持

## Python数据库API

虽然有很多种数据库，比如Oracle、MySQL和SQLite等。但是Python提供了一个标准数据库API（DB API）。 这个API的最新版本（2.0）是在PEP 249（Python Database API
Specification v2.0）中定义的，网址为http://python.org/peps/pep-0249.html。  
就是说连接MySQL的数据库模块和连接Oracle的数据库模块都遵守这个API的规定，比如其中的连接数据库的方法都叫`connect`。  
但是也有一些可选部分，不一定适用于所有的数据库。

### 13.1.1 全局变量

所有与DB2.0兼容的数据库模块都必须包含三个全局变量，他们描述了模块的特征。通过检查这三个变量，可以确定 这个模块是否是程序可以接受的。如果不是，就显示合适的错误信息或退出或引发异常。   
Python DB API的模块属性

|变量名|描述|
|---|---|
|apilevel|使用的Python DB API版本|
|threadsafety|模块的线程安全程度如何|
|paramstyle|在SQL查询中使用哪种参数风格|

API级别（apilevel）是一个字符串常量，指出了使用的API版本。 DB API 2.0指出，这个变 量的值为'1.0'或'2.0'
。如果没有这个变量，就说明模块不与DB API 2.0兼容，应假定使用的是 DB API 1.0。

线程安全程度（threadsafety）是一个0~3（含）的整数。0表示线程不能共享模块，而3表 示模块是绝对线程安全的。1表示线程可共享模块本身，但不能共享连接（参见13.1.3节），而2 表示线程可共享模块和连接，但不能共享游标。

参数风格（paramstyle）表示当你执行多个类似的数据库查询时，如何在SQL查询中插入参 数。'format'
表示标准字符串格式设置方式（使用基本的格式编码），如在要插入参数的地方插 入%s。'pyformat'表示扩展的格式编码，即旧式字典插入使用的格式编码，如%(
foo)s。除这些 Python风格外，还有三种指定待插入字段的方式：'qmark'表示使用问号，'numeric'表示使用:1 和:
2这样的形式表示字段（其中的数字是参数的编号），而'named'表示使用:foobar这样的形式表示字段（其中foobar为参数名）。

### 13.1.2 异常

DB API定义了多种异常，可以细致得区分出错误。而且也构成了异常层次结构，可以使用一个except捕获多种异常。

Python DB API指定的异常

|异常|超类|描述|
|---|---|---|
|StandardError| |所有异常的超类|
|Warning|StandardError|发生非致命问题时引发|
|Error|StandardError|所有错误条件的超类|
|InterfaceError|Error|与接口（而不是数据库）相关的错误|
|DatabaseError|Error|与数据库相关的错误的超类|
|DataError|DatabaseError|与数据相关的问题，如值不在合法的范围内|
|OperationalError|DatabaseError|数据库操作内部的错误|
|IntegrityError|DatabaseError|关系完整性遭到破坏，如键未通过检查|
|InternalError|DatabaseError|数据库内部的错误，如游标无效|
|ProgrammingError|DatabaseError|用户编程错误，如未找到数据库表|
|NotSupportedError|DatabaseError|请求不支持的功能，如回滚|

### 13.1.3 连接和游标

要连接到数据库，可以使用connect函数。这个函数有多个参数，具体根据数据库不同而不同。 作为指南， DB API定义了下表所示的参数。推荐将这些参数定义为关键字参数，并按表所示的顺序排列。 这些参数都应该是**字符串**。

|参数名|描述|是否可选|
|---|---|---|
|dsn|数据源名称，具体含义随数据库而异|否|
|user|用户名 |是|
|password|用户密码 |是|
|host|主机名|是|
|database|数据库名称|是|

函数connect返回一个连接对象，表示当前到数据库的会话。连接对象支持下表所示的方法。

|方法名|描述|
|---|---|
|close()|关闭连接对象。之后，连接对象及其游标将不可用|
|commit()|提交未提交的事务——如果支持的话；否则什么都不做|
|rollback()|回滚未提交的事务（可能不可用）|
|cursor()|返回连接的游标对象|

方法rollback可能不可用，因为并非所有的数据库都支持事务（事务其实就是一系列操作）。 可用时，这个方法撤销所有未提交的事务。

方法commit总是可用的，但如果数据库不支持事务，这个方法就什么都不做。

方法cursor，返回一个游标对象，游标对象来执行SQL查询和查看结果。游标支持的方法比连接多， 在程序中的地位也重要得多。下表概述了游标的方法和游标的属性。

游标对象的方法

|名称|描述|
|---|---|
|callproc(name[, params]) |使用指定的参数调用指定的数据库过程（可选）|
|close() |关闭游标。关闭后游标不可用|
|execute(oper[, params]) |执行一个SQL操作——可能指定参数|
|executemany(oper, pseq) |执行指定的SQL操作多次，每次都序列中的一组参数|
|fetchone() |以序列的方式取回查询结果中的下一行；如果没有更多的行，就返回None|
|fetchmany([size]) |取回查询结果中的多行，其中参数size的值默认为arraysize|
|fetchall() |以序列的序列的方式取回余下的所有行|
|nextset() |跳到下一个结果集，这个方法是可选的|
|setinputsizes(sizes) |用于为参数预定义内存区域|
|setoutputsize(size[, col]) |为取回大量数据而设置缓冲区长度|

游标对象的属性

|名称|描述|
|---|---|
|description|由结果列描述组成的序列（只读）|
|rowcount|结果包含的行数（只读）|
|arraysize|fetchmany返回的行数，默认为1|

### 13.1.4 类型

对于插入到某些类型的列中的值，底层SQL数据库可能要求它们满足一定的条件。 为了能够与底层SQL数据库正确地互操作， DB API定义了一些构造函数和常量（单例），用于提供特殊的类型和值。  
例如，要在数据库中添加日期，应使用相应数据库连接模块中的构造函数Date来创建它，这让连接模块能够在幕后执行必要的转换。  
每个模块都必须实现下表所示的构造函数和特殊值。有些模块可能没有完全遵守这一点。

DB API构造函数和特殊值

|名称|描述|
|---|---|
|Date(year, month, day)|创建包含日期值的对象|
|Time(hour, minute, second)|创建包含时间值的对象|
|Timestamp(y, mon, d, h, min, s)|创建包含时间戳的对象|
|DateFromTicks(ticks)|根据从新纪元开始过去的秒数创建包含日期值的对象|
|TimeFromTicks(ticks)|根据从新纪元开始过去的秒数创建包含时间值的对象|
|imestampFromTicks(ticks)|根据从新纪元开始过去的秒数创建包含时间戳的对象|
|Binary(string)|创建包含二进制字符串值的对象|
|STRING|描述基于字符串的列（如CHAR）|
|BINARY|描述二进制列（如LONG或RAW）|
|NUMBER|描述数字列|
|DATETIME|描述日期/时间列|
|ROWID|描述行ID列|

## 13.2 SQLite和PySQLite

这里使用SQLite来进行示范，因为SQLLite可以直接使用本地文件，不用再服务器上搭建。  
而且，在较新版本的Python中，标准库包含一个SQLite包装器:使用模块sqlite3实现的PySQLite。 如果下面13.2.1中的代码片段能运行，那就无需专门安装PySQLite和SQLite了。

### 13.2.1 起步

```shell
import sqlite3
# 创建到数据库文件的链接，如果不存在，那么会自动创建
conn = sqlite3.connect('somedatabase.db')
# 获取游标
curs = conn.cursor()
# 提交修改
conn.commit()
# 关闭连接
conn.close()
```
### 13.2.2 数据库应用程序示例
假如提供了如下形式的数据集
```text
~07276~^~HORMEL SPAM ... PORK W/ HAM MINCED CND~^ ... ^~1 serving~^^~~^0
```
其中每一行都是一条记录，字段之间用脱字符(^)分隔。数字字段直接包含数字，而文本字段用两个波浪字符（~）将其字符串值括起。  
所以要解析它，可以使用line.split('^')，之后对于每个字段，如果以~开头，那就使用field.strip('~')来获取内容。
对于其他字段（即数字字段），使用float(field)就能获取其内容，但字段为空时不能这样做。

1. 创建并填充数据库表
```python
import sqlite3
def convert(value):
    if value:
        if value.startswith('~'):
            return value.strip('~')
        else:
            return float(value)
    else:
        return 0

conn = sqlite3.connect('food.db')
curs = conn.cursor()

curs.execute('''
CREATE TABLE food (
id TEXT PRIMARY KEY,
desc TEXT,
water FLOAT,
kcal FLOAT,
protein FLOAT,
fat FLOAT,
ash FLOAT,
carbs FLOAT,
fiber FLOAT,
sugar FLOAT
)
''')

query = 'INSERT INTO food VALUES (?,?,?,?,?,?,?,?,?,?)'
field_count = 10
for line in open('ABBREV.txt'):
    fields = line.split('^')
    # 这步很机智，想对列表前10项进行处理生成新的列表，先将旧列表切片，再列表推导处理
    vals = [convert(f) for f in fields[:field_count]]
    curs.execute(query, vals)

conn.commit()
conn.close()
```
注意：也可使用curs.executemany，并向它提供一个列表（其中包含从数据文件中提取的所有行）。
就这里而言，这样做速度稍有提高，但如果使用的是通过网络连接的客户/服务器SQL系统，速度将有极大的提高。

2. 搜索并处理结果

使用起来比较简单：先创建连接，再获取游标；使用execute执行SQL，在再使用fetchall等方法提取结果。  
问题是SQLite处理其值的方式不那么标准，事实上，它在内部将所有的值都表示为字符串，
因此在数据库和Python API之间将执行一些转换和检查。
比如查询ID为08323的记录，他将解读为数字8323，进而转成字符串'8323'，一个不存在的ID。


食品数据库查询程序
```python
import sqlite3, sys
conn = sqlite3.connect('food.db')
curs = conn.cursor()
query = 'SELECT * FROM food WHERE ' + sys.argv[1]
print(query)
curs.execute(query)
names = [f[0] for f in curs.description]
for row in curs.fetchall():
    for pair in zip(names, row):
        print('{}: {}'.format(*pair))
print()
```
> 然而，利用这种输入偷偷地插入恶意的SQL代码以破坏数据库是一种常见的计算机攻击方式，称为SQL注入攻击。