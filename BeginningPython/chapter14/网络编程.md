# 网络编程

## 14.1 几个网络模块

### 14.1.1 模块socket

套接字是网络编程中的一个基本组件。套接字基本上是一个信息通道，两端各有一个程序，这些程序可能位于网络上不同的计算机上，通过套接字来发送信息。 Python中，大多数网络编程都隐藏了模块socket的基本工作原理，不与套接字直接交互。

套接字分为两类：服务器套接字和客户端套接字。  
服务端套接字：等待连接请求，在某个地址+端口处监听，直到客户套接字建立连接。  
客户端套接字：连接服务端套接字，完成后断开连接。

套接字是`模块socket`中`socket类`的实例。实例化套接字时最多可指定三个参数:  
一个地址族 (默认为socket.AF_INET);  
是流套接字(socket.SOCK_STREAM，默认设置)还是数据报套接字 (socket.SOCK_DGRAM);  
协议(使用默认值0就好)。  
创建普通套接字时，不用提供任何参数。

服务器套接字先调用方法bind，再调用方法listen来监听特定的地址。然后客户端套接字就可以连接到服务器了，方法是使用connet并提供调用bind时的地址。
(在服务器端， 可使用函数socket.gethostname获取当前机器的主机名)。这里的地址是一个格式为(host, port)的元组。 方法listen接 受一个参数——待办任务清单的长度(
即最多可有多少个连接在队列中等待接纳，到达这个数量后将开始拒绝连接)。  
服务器套接字开始监听之后，就可以接受客户端的连接了，这是使用方法accept来完成的。这个方法将阻断（等待）到客户端连接到来为止， 然后返回一个格式为(client, address)
的元组，其中client是一个客户端套接字，而address是地址。
> 这里讨论的服务器编程形式称为阻断(同步)网络编程。

为传输数据，套接字提供了两个方法:send和recv(表示receive)。要发送数据，可调用方法send并提供一个字符串;要接收数据，可调用recv并指定最多接收多少个字节的数据。 如果不 确定该指定什么数字，1024是个不错的选择。

举例：最见到的客户端和服务器程序。

```python
# 最简单的服务器
import socket

# 创建socket实例
s = socket.socket()
host = socket.gethostname()
port = 8765
# 先调用bind方法
s.bind((host, port))
# 在调用listen方法开始监听 5表示最多可有5个连接在队列中等待接纳
s.listen(5)
while True:
    c, addr = s.accept()
    print('Got connection from', addr)
    c.send(b'Thank you for connecting')
    c.close()
```

```python
# 最简单的客户端
import socket

s = socket.socket()

host = socket.gethostname()
port = 8765

# 连接到服务器
s.connect((host, port))
print(s.recv(1024))
```

### 14.1.2 模块urllib和urllib2

urllib和urllib2可以通过网络访问文件。通过简单的函数调用，就几乎可以将统一资源定位符（URL)可指向的任何动作作为程序的输入。 通过和正则表达式模块re进行结合，可以下载网页并提取信息
urllib2比urllib更好，urllib2相比于urllib来说，可以实现HTTP身份验证或Cookie，或编写扩展来处理自己的协议。

1. 打开远程文件

使用模块urllib.request中的函数urlopen，就可以像打开本地文件那样打开远程文件，但是只能使用读取模式

```python
from urllib.request import urlopen

# webpage是一个类似于文件的对象
webpage = urlopen('http://www.python.org')
```

urlopen返回的类似于文件的对象支持方法close、read、readline和readlines，还支持迭代等。   
比如要找出网页链接中About的相对URL，可使用正则表达式

```python
from urllib.request import urlopen
import re

# 注意要在编译正则表达式的时候指定是否忽略大小写属性
pat = re.compile(b'<a href="([^"]+)" .*?>about</a>', re.IGNORECASE)
webpage = urlopen('http://www.python.org')
text = webpage.read()
m = pat.search(text)
print(m.group(1))
```

2. 获取远程文件

函数urlopen返回一个类似于文件的对象，可从中读取数据。如果要让urllib替你下载文件， 并将其副本存储在一个本地文件中，可使用urlretrieve。 这个函数不返回一个类似于文件的对象，而返回一个格式为(filename,
headers)的元组，其中filename是本地文件的名称(由urllib 自动创建)， 而headers包含一些有关远程文件的信息(这里不会介绍headers，如果你想更深入地
了解它，请在有关urllib的标准库文档中查找urlretrieve)。 如果要给下载的副本指定文件名， 可通过第二个参数来提供。

```python
# 获取Python官网的主页，并将其存储到文件C:\python_webpage.html中
from urllib.request import urlretrieve

urlretrieve('http://www.python.org', 'C:\\python_webpage.html')
```

如果你没有指定文件名，下载的副本将放在某个临时位置，可使用函数open来打开。 但使用完毕后，你可能想将其删除，以免占用磁盘空间。要清空这样的临时文件，可调用函数urlcleanup且不提供任何参数， 它将负责替你完成清空工作。

> 一些实用的函数
> + quote(string[, safe]):返回一个字符串，其中所有的特殊字符(在URL中有特殊意义的字符)都已替换为对URL友好的版本(如将~替换为%7E)。
    > 如果要将包含特殊字符的 字符串用作URL，这很有用。参数safe是一个字符串(默认为'/')，包含不应像这样对其进行编码的字符。
> + quote_plus(string[, safe]):类似于quote，但也将空格替换为加号。
> + unquote(string):与quote相反。
> + unquote_plus(string):与quote_plus相反。
> + urlencode(query[, doseq]):将映射(如字典)或由包含两个元素的元组(形如(key, value))组成的序列转换为“使用URL编码的”字符串。
    > 这样的字符串可用于CGI查询中(详 细信息请参阅Python文档)。

14.1.3 其他模块

|模块|描述|
|---|---|
|asynchat       |包含补充asyncore的功能(参见第24章)                |
|asyncore       |异步套接字处理程序(参见第24章)                      |
|cgi            |基本的CGI支持(参见第15章)                       |
|Cookie         |Cookie对象操作，主要用于服务器                     |
|cookielib      |客户端Cookie支持                            |
|email          |电子邮件(包括MIME)支持                         |
|ftplib         |FTP客户端模块                               |
|gopherlib      |Gopher客户端模块                            |
|httplib        |HTTP 客户端模块                             |
|imaplib        |IMAP4客户端模块                             |
|mailbox        |读取多种邮箱格式                               |
|mailcap        |通过mailcap文件访问MIME配置                    |
|mhlib          |访问MH邮箱                                 |
|nntplib        |NNTP客户端模块(参见第23章)                      |
|poplib         |POP客户端模块                               |
|robotparser |解析Web服务器robot文件                           |
|SimpleXMLRPCServer |一个简单的XML-RPC服务器(参见第27章)            |
|smtpd|SMTP服务器模块                                        |
|smtplib |SMTP客户端模块                                     |
|telnetlib |Telnet客户端模块                                 |
|urlparse |用于解读URL                                      |
|xmlrpclib|XML-RPC客户端支持(参见第27章)                         |

## 14.2 SocketServer及相关的类

我们虽然可以通过socket模块来编写简单的套接字服务器，但是如果要编写复杂的服务器，还是使用 服务器模块比较好。模块SocketServer是标准库提供的服务器框架的基石。包括BaseHTTPServer、
SimpleHTTPServer、 CGIHTTPServer、 SimpleXMLRPCServer和DocXMLRPCServer等服务器， 它们在基本服务器的基础上添加了各种功能。  
SocketServer包含4个基本的服务器： TCPServer（支持TCP套接字流）、 UDPServer（支持UDP
数据报套接字）以及更难懂的UnixStreamServer和UnixDatagramServer。基本上不会用到后三个。  
在使用模块SocketServer编写服务器时，大部分代码写在请求处理器中。服务端收到客户连接请求时， 实例化请求处理程序，并对其调用各种处理方法来处理请求。具体依赖于使用的服务器类和请求处理程序类；
还可从这些请求处理器类派生出子类，从而让服务器调用一组自定义的处理方法。 基本请求处理程序类BaseRequestHandler将所有操作都放在一个方法中——服务器调用的方法handle。
这个方法可通过属性self.request来访问客户端套接字。如果处理的是流（使用TCPServer时很可能如此） ，可使用StreamRequestHandler类，它包含另外两个属性：
self.rfile（用于读取）和self.wfile（用于写入）。 你可使用这两个类似于文件的对象来与客户端通信。

```python
# 基于SocketServer的极简服务器
from socketserver import TCPServer, StreamRequestHandler


# 继承StreamRequestHandler，它已经实现了关闭连接的操作，所以我们只需要重写handle
class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')


server = TCPServer(('', 1234), Handler)
server.serve_forever()

```

## 14.3 多个连接

之前的示例服务器都是同步的：不能同时处理多个客户端的连接请求。  
处理多个连接的主要方式有三种：分叉（forking）、线程化和异步I/O。通过结合使用SocketServer中的混合类和服务器类，可以容易地实现分叉和线程化。
然而分叉占用的姿态资源较多，且在客户端很多时可伸缩性不佳。而线程化可能带来同步问题。
> 分叉和线程是什么  
> 分叉是一个UNIX术语。对进程分叉就是复制它，两个进程都从当前位置继续运行，每个进程都有自己的内存副本。
> 原来的进程是父进程，复制出来的是子进程。  
> 在分叉服务器中，对于每个客户端连接，都将创建一个子进程进行处理，父进程继续监听新连接。客户端
> 请求结束之后，子进程直接退出。因为分叉出来的进程并行地运行，所以客户端无需等待。
>
> 由于分叉占用资源较多（每个进程都必须有自己的内存），所以另一种解决方式是线程化。线程是轻量级的进程，
> 每个线程都位于同一个进程中，共享同一个进程中的内存。所以必须处理进程之间的同步问题。  
> 在现代操作系统（不支持分叉的Windows除外）中，分叉的速度其实非常快，较新的硬件能够更好地应付其资源消耗。如果你不想处理麻烦的同步问题，分叉可能是不错的选择

### 14.3.1 使用SocketServer实现分叉和线程化

```python
# 分叉服务器
from socketserver import TCPServer, ForkingMixIn, StreamRequestHandler


class Server(ForkingMixIn, TCPServer): pass


class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')


server = Server(('', 1234), Handler)
server.serve_forever()
```

```python
# 线程化服务器
from socketserver import TCPServer, ThreadingMixIn, StreamRequestHandler


class Server(ThreadingMixIn, TCPServer): pass


class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')


server = Server(('', 1234), Handler)
server.serve_forever()
```

### 14.3.2 使用select和poll实现异步I/O

使用分叉和线程化时，不用担心客户端的数据时断时续，因为一个进程（线程）等待数据时，其他进程（线程）可继续处理其客户端。 然而另一种做法是只处理当前正在通信的客户端。你甚至无需不断监听，只需监听后将客户端加入队列即可。  
框架asyncore/asynchat和Twisted采取的就是上面的方法。这种功能的基础是函数select和poll（如果系统支持）。
两个函数都位于select模块中，其中poll的可伸缩性更高，但只有UNIX系统支持它（Windows不支持）。

函数select接受三个必不可少的参数和一个可选参数，其中前三个参数为序列，而第四个参数为超时时间（单位为秒）。  
这些序列包含文件描述符整数（也可以是这样的对象：包含返回文件描述符整数的方法fileno），表示我们正在等待的连接。这三个序列分别表示需要输入和输出以及发生异常（错误等）的连接。  
如果没有指定超时时间， select将阻断（即等待）到有文件描述符准备就绪；如果指定了超时时间， select将最多阻断指定的秒数；如果超时时间为零， select将不断轮询（即不阻断）。  
select返回三个序列（即一个长度为3的元组），其中每个序列都包含相应参数中处于活动状态的文件描述符。例如，返回的第一个序列包含有数据需要读取的所有输入文件描述符。

这些序列也可包含文件对象（Windows不支持）或套接字。下面的代码所示的服务器使用select来为多个连接提供服务。
（请注意，将服务器套接字传递给了select，让select能够在有新连接到来时发出信号。）这个服务器是一个简单的日志程序，将来自客户端的数据都打印出来。

```python
# 使用select的简单服务器
import socket, select

s = socket.socket()
host = socket.gethostname()
port = 1234
s.bind(host, port)
s.listen(5)
inputs = [s]
while True:
    # 参数的三个序列分别表示需要输入和输出以及发生异常（错误等）的连接。
    # 返回的每个序列都包含相应参数中处于活动状态的文件描述符。
    rs, ws, es = select.select(inputs, [], [])
    for r in rs:
        if r is s:
            c, addr = s.accept()
            print('Got connection from', addr)
            inputs.append(c)
    else:
        try:
            data = r.recv(1024)
            disconnected = not data
        except socket.error:
            disconnected = True
        if disconnected:
            print(r.getpeername(), 'disconnected')
            inputs.remove(r)
        else:
            print(data)
```

方法poll使用起来比select容易。调用poll时，将返回一个轮询对象。可使用方法register向这个对象注册文件描述符(或包含方法fileno的对象)。 注册后可使用方法unregister将它们删 除。注册对象(如套接字)
后，可调用其方法poll(它接受一个可选的超时时间参数)。 这将返回一个包含(fd, event)元组的列表(可能为空)，其中fd为文件描述符，而event是发生的事件。
event是一个位掩码，这意味着它是一个整数，其各个位对应于不同的事件。各种事件是用select模块中的常量表示的，如表所示。 要检查指定的位是否为1(即是否发生了相应的事件)，可下面这样使用按位与运算符(&):  
`if event & select.POLLIN: ...`

|事件名|描述|
|---|---|
|POLLIN|文件描述符中有需要读取的数据|
|POLLPRI|文件描述符中有需要读取的紧急数据|
|POLLOUT|文件描述符为写入数据做好了准备|
|POLLERR|文件描述符出现了错误状态|
|POLLUP|挂起。连接已断开|
|POLLNVAL|无效请求。连接未打开|

使用poll而不是select重写了使用select所示的服务器。请注意，添加了一个从文件描述符(int)到套接字对象的映射(fdmap)。

```python
# 使用poll的简单服务器
import socket, select

s = socket.socket()

host = socket.gethostname()
port = 1234
s.bind((host, port))

fdmap = {s.fileno(): s}

s.listen(5)

p = select.poll()
p.register(s)
while True:
    events = p.poll()
    for fd, event in events:
        if fd in fdmap:
            c, addr = s.accept()
            print('Got connection from', addr)
            p.register(c)
            fdmap[c.fileno()] = c
        elif event & select.POLLIN:
            data = fdmap[fd].recv(1024)
            if not data:  # 没有连接 --连接已关闭
                print(fdmap[fd].getpeername(), 'disconnected')
                p.unregister(fd)
                del fdmap[fd]
            else:
                print(data)
```

## 14.4 Twisted

Twisted是一个**事件驱动**的Python网络框架，最初是为编写网络游戏开发的。在Twisted中，可以实现事件处理程序。 实际上，Twisted和多个GUI工具包（Tk，GTK，Qt和wxWidgets）合作得天衣无缝。  
Twisted是一个功能极其丰富的框架，支持Web服务器和客户端、SSH2、 SMTP、POP3、IMAP4、AIM、ICQ、IRC、MSN、Jabber、NNTP、DNS等。

### 14.4.1 下载并安装Twisted

```shell
pip install Twisted
```

### 14.4.2 编写Twisted服务器

Twisted采用的是基于事件的方法。要编写简单的服务器，只需实现如下情景的事件处理程序：客服端发起连接，有数据到来，客户端断开连接（以及众多其他的事件）。
专用类可在基本类上定义更细致的事件。如包装“数据到来”事件，收集换行符之前的所有数据再分派“数据行到来”事件。
> 注意，Twisted的延迟对象和延迟执行没有介绍。可以参考Twisted文档。

事件处理程序是在协议中定义的。所以需要一个工厂，在新连接到来的时候负责创建这样的协议对象。
如果你只想创建自定义协议类的实例，可使用Twisted自带的工厂——模块twisted.internet.protocol中的 Factory 类 。
编写自定义协议时，将模块twisted.internet.protocol中的Protocol作为超类。
有新连接到来时，将调用事件处理程序connectionMade;连接中断时，将调用connectionLost。
来自客户端的数据是通过处理程序dataReceived接收的。
当然，你不能使用事件处理策略来向客户端发送数据。 这种工作是使用对象self.transport完成的，它包含一个write方法。
这个对象还有一个client属性，其中包含客户端的地址(主机名和端口)。

下面是一个使用Twisted编写的服务器。其中包含一些设置工作：实例化Factory并设置其protocol属性，让它知道使用哪种协议（这里是我们自定义的协议）与客户端通信。  
接下来开始监听指定端口，让工厂来实例化协议对象处理连接。为此，调用了模块reactor中的函数listenTCP。最后使用reactor模块的run函数启动服务器。
```python
from twisted.internet import reactor
from twisted.internet.protocol import Protocol, Factory

# 自定义协议继承Protocol类
class SimpleLogger(Protocol):
    def connectionMade(self):
        print('Got connection from', self.transport.client)

    def connectionLost(self, reason):
        print(self.transport.client, 'disconnected')

    def dataReceived(self, data):
        print(data)

# 实例化Factory，并设置Protocol属性
factory = Factory()
factory.protocol = SimpleLogger

# factory负责在新连接来到的时候创建协议对象
reactor.listenTCP(1234, factory)
reactor.run()

```

模块twisted.protocols.basic包含几个预定义的协议，其中一个就是 LineReceiver。
它实现了dataReceived，并在每收到一整行后调用事件处理程序lineReceived。
> 提示 要在收到数据后做些除调用lineReceived(它依赖实现了dataReceived的LineReceiver)外的其他事情，可使用LineReceiver定义的事件处理程序rawDataReceived。 

```python
# 使用协议LineReceiver改进后的日志服务器
from twisted.internet import reactor
from twisted.internet.protocol import Protocol, Factory
from twisted.protocols.basic import LineReceiver

# 自定义协议继承Protocol类
class SimpleLogger(LineReceiver):
    def connectionMade(self):
        print('Got connection from', self.transport.client)

    def connectionLost(self, reason):
        print(self.transport.client, 'disconnected')

    def lineReceived(self, line):
        print(line)

# 实例化Factory，并设置Protocol属性
factory = Factory()
factory.protocol = SimpleLogger

# factory负责在新连接来到的时候创建协议对象
reactor.listenTCP(1234, factory)
reactor.run()
```

