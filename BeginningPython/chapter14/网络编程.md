# 网络编程
## 14.1 几个网络模块
### 14.1.1 模块socket
套接字是网络编程中的一个基本组件。套接字基本上是一个信息通道，两端各有一个程序，这些程序可能位于网络上不同的计算机上，通过套接字来发送信息。
Python中，大多数网络编程都隐藏了模块socket的基本工作原理，不与套接字直接交互。  

套接字分为两类：服务器套接字和客户端套接字。  
服务端套接字：等待连接请求，在某个地址+端口处监听，直到客户套接字建立连接。  
客户端套接字：连接服务端套接字，完成后断开连接。  

套接字是`模块socket`中`socket类`的实例。实例化套接字时最多可指定三个参数:  
一个地址族 (默认为socket.AF_INET);  
是流套接字(socket.SOCK_STREAM，默认设置)还是数据报套接字 (socket.SOCK_DGRAM);  
协议(使用默认值0就好)。  
创建普通套接字时，不用提供任何参数。  

服务器套接字先调用方法bind，再调用方法listen来监听特定的地址。然后客户端套接字就可以连接到服务器了，方法是使用connet并提供调用bind时的地址。
(在服务器端， 可使用函数socket.gethostname获取当前机器的主机名)。这里的地址是一个格式为(host, port)的元组。
方法listen接 受一个参数——待办任务清单的长度(即最多可有多少个连接在队列中等待接纳，到达这个数量后将开始拒绝连接)。  
服务器套接字开始监听之后，就可以接受客户端的连接了，这是使用方法accept来完成的。这个方法将阻断（等待）到客户端连接到来为止，
然后返回一个格式为(client, address)的元组，其中client是一个客户端套接字，而address是地址。
> 这里讨论的服务器编程形式称为阻断(同步)网络编程。

为传输数据，套接字提供了两个方法:send和recv(表示receive)。要发送数据，可调用方法send并提供一个字符串;要接收数据，可调用recv并指定最多接收多少个字节的数据。
如果不 确定该指定什么数字，1024是个不错的选择。

举例：最见到的客户端和服务器程序。
```python
# 最简单的服务器
import socket
# 创建socket实例
s = socket.socket()
host = socket.gethostname()
port = 8765
# 先调用bind方法
s.bind((host, port))
# 在调用listen方法开始监听 5表示最多可有5个连接在队列中等待接纳
s.listen(5)
while True:
    c, addr = s.accept()
    print('Got connection from', addr) 
    c.send(b'Thank you for connecting')
    c.close()
```
```python
# 最简单的客户端
import socket
s = socket.socket()

host = socket.gethostname()
port = 8765

# 连接到服务器
s.connect((host, port))
print(s.recv(1024))
```

### 14.1.2 模块urllib和urllib2
urllib和urllib2可以通过网络访问文件。通过简单的函数调用，就几乎可以将统一资源定位符（URL)可指向的任何动作作为程序的输入。
通过和正则表达式模块re进行结合，可以下载网页并提取信息
urllib2比urllib更好，urllib2相比于urllib来说，可以实现HTTP身份验证或Cookie，或编写扩展来处理自己的协议。

1. 打开远程文件

使用模块urllib.request中的函数urlopen，就可以像打开本地文件那样打开远程文件，但是只能使用读取模式
```python
from urllib.request import urlopen
# webpage是一个类似于文件的对象
webpage = urlopen('http://www.python.org')
```
urlopen返回的类似于文件的对象支持方法close、read、readline和readlines，还支持迭代等。   
比如要找出网页链接中About的相对URL，可使用正则表达式
```python
from urllib.request import urlopen
import re
# 注意要在编译正则表达式的时候指定是否忽略大小写属性
pat = re.compile(b'<a href="([^"]+)" .*?>about</a>', re.IGNORECASE)
webpage = urlopen('http://www.python.org')
text = webpage.read()
m = pat.search(text)
print(m.group(1))
```

2. 获取远程文件

函数urlopen返回一个类似于文件的对象，可从中读取数据。如果要让urllib替你下载文件， 并将其副本存储在一个本地文件中，可使用urlretrieve。
这个函数不返回一个类似于文件的对象，而返回一个格式为(filename, headers)的元组，其中filename是本地文件的名称(由urllib 自动创建)，
而headers包含一些有关远程文件的信息(这里不会介绍headers，如果你想更深入地 了解它，请在有关urllib的标准库文档中查找urlretrieve)。
如果要给下载的副本指定文件名， 可通过第二个参数来提供。
```python
# 获取Python官网的主页，并将其存储到文件C:\python_webpage.html中
from urllib.request import urlretrieve
urlretrieve('http://www.python.org', 'C:\\python_webpage.html')
```
如果你没有指定文件名，下载的副本将放在某个临时位置，可使用函数open来打开。
但使用完毕后，你可能想将其删除，以免占用磁盘空间。要清空这样的临时文件，可调用函数urlcleanup且不提供任何参数，
它将负责替你完成清空工作。

> 一些实用的函数  
> + quote(string[, safe]):返回一个字符串，其中所有的特殊字符(在URL中有特殊意义的字符)都已替换为对URL友好的版本(如将~替换为%7E)。
> 如果要将包含特殊字符的 字符串用作URL，这很有用。参数safe是一个字符串(默认为'/')，包含不应像这样对其进行编码的字符。  
> + quote_plus(string[, safe]):类似于quote，但也将空格替换为加号。  
> + unquote(string):与quote相反。  
> + unquote_plus(string):与quote_plus相反。  
> + urlencode(query[, doseq]):将映射(如字典)或由包含两个元素的元组(形如(key, value))组成的序列转换为“使用URL编码的”字符串。
> 这样的字符串可用于CGI查询中(详 细信息请参阅Python文档)。

14.1.3 其他模块

|模块|描述|
|---|---|
|asynchat       |包含补充asyncore的功能(参见第24章)                |
|asyncore       |异步套接字处理程序(参见第24章)                      |
|cgi            |基本的CGI支持(参见第15章)                       |
|Cookie         |Cookie对象操作，主要用于服务器                     |
|cookielib      |客户端Cookie支持                            |
|email          |电子邮件(包括MIME)支持                         |
|ftplib         |FTP客户端模块                               |
|gopherlib      |Gopher客户端模块                            |
|httplib        |HTTP 客户端模块                             |
|imaplib        |IMAP4客户端模块                             |
|mailbox        |读取多种邮箱格式                               |
|mailcap        |通过mailcap文件访问MIME配置                    |
|mhlib          |访问MH邮箱                                 |
|nntplib        |NNTP客户端模块(参见第23章)                      |
|poplib         |POP客户端模块                               |
|robotparser |解析Web服务器robot文件                           |
|SimpleXMLRPCServer |一个简单的XML-RPC服务器(参见第27章)            |
|smtpd|SMTP服务器模块                                        |
|smtplib |SMTP客户端模块                                     |
|telnetlib |Telnet客户端模块                                 |
|urlparse |用于解读URL                                      |
|xmlrpclib|XML-RPC客户端支持(参见第27章)                         |
      



    
  


 


## 14.2 SocketServer及相关的类
我们虽然可以通过socket模块来编写简单的套接字服务器，但是如果要编写复杂的服务器，还是使用
服务器模块比较好。模块SocketServer是标准库提供的服务器框架的基石。包括BaseHTTPServer、
SimpleHTTPServer、 CGIHTTPServer、 SimpleXMLRPCServer和DocXMLRPCServer等服务器，
它们在基本服务器的基础上添加了各种功能。  
SocketServer包含4个基本的服务器： TCPServer（支持TCP套接字流）、 UDPServer（支持UDP
数据报套接字）以及更难懂的UnixStreamServer和UnixDatagramServer。基本上不会用到后三个。  
在使用模块SocketServer编写服务器时，大部分代码写在请求处理器中。服务端收到客户连接请求时，
实例化请求处理程序，并对其调用各种处理方法来处理请求。具体依赖于使用的服务器类和请求处理程序类；
还可从这些请求处理器类派生出子类，从而让服务器调用一组自定义的处理方法。
基本请求处理程序类BaseRequestHandler将所有操作都放在一个方法中——服务器调用的方法handle。
这个方法可通过属性self.request来访问客户端套接字。如果处理的是流（使用TCPServer时很可能如此）
，可使用StreamRequestHandler类，它包含另外两个属性： self.rfile（用于读取）和self.wfile（用于写入）。
你可使用这两个类似于文件的对象来与客户端通信。
```python
# 基于SocketServer的极简服务器
from socketserver import TCPServer, StreamRequestHandler
# 继承StreamRequestHandler，它已经实现了关闭连接的操作，所以我们只需要重写handle
class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')

server = TCPServer(('', 1234), Handler)
server.serve_forever()

```

## 14.3 多个连接
之前的示例服务器都是同步的：不能同时处理多个客户端的连接请求。  
处理多个连接的主要方式有三种：分叉（forking）、线程化和异步I/O。通过结合使用SocketServer中的混合类和服务器类，可以容易地实现分叉和线程化。
然而分叉占用的姿态资源较多，且在客户端很多时可伸缩性不佳。而线程化可能带来同步问题。
> 分叉和线程是什么  
> 分叉是一个UNIX术语。对进程分叉就是复制它，两个进程都从当前位置继续运行，每个进程都有自己的内存副本。
> 原来的进程是父进程，复制出来的是子进程。  
> 在分叉服务器中，对于每个客户端连接，都将创建一个子进程进行处理，父进程继续监听新连接。客户端
> 请求结束之后，子进程直接退出。因为分叉出来的进程并行地运行，所以客户端无需等待。
> 
> 由于分叉占用资源较多（每个进程都必须有自己的内存），所以另一种解决方式是线程化。线程是轻量级的进程，
> 每个线程都位于同一个进程中，共享同一个进程中的内存。所以必须处理进程之间的同步问题。  
> 在现代操作系统（不支持分叉的Windows除外）中，分叉的速度其实非常快，较新的硬件能够更好地应付其资源消耗。如果你不想处理麻烦的同步问题，分叉可能是不错的选择

### 14.3.1 使用SocketServer实现分叉和线程化
```python
# 分叉服务器
from socketserver import TCPServer, ForkingMixIn, StreamRequestHandler
class Server(ForkingMixIn, TCPServer): pass
class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')
server = Server(('', 1234), Handler)
server.serve_forever()
```
```python
# 线程化服务器
from socketserver import TCPServer, ThreadingMixIn, StreamRequestHandler
class Server(ThreadingMixIn, TCPServer): pass
class Handler(StreamRequestHandler):
    def handle(self):
        addr = self.request.getpeername()
        print('Got connection from', addr)
        self.wfile.write('Thank you for connecting')
server = Server(('', 1234), Handler)
server.serve_forever()
```

### 14.3.2 使用select和poll实现异步I/O
使用分叉和线程化时，不用担心客户端的数据时断时续，因为一个进程（线程）等待数据时，其他进程（线程）可继续处理其客户端。
然而另一种做法是只处理当前正在通信的客户端。你甚至无需不断监听，只需监听后将客户端加入队列即可。  
框架asyncore/asynchat和Twisted采取的就是上面的方法。这种功能的基础是函数select和poll（如果系统支持）。
两个函数都位于select模块中，其中poll的可伸缩性更高，但只有UNIX系统支持它（Windows不支持）。  

函数select接受三个必不可少的参数和一个可选参数，其中前三个参数为序列，而第四个参数为超时时间（单位为秒）。  
这些序列包含文件描述符整数（也可以是这样的对象：包含返回文件描述符整数的方法fileno），表示我们正在等待的连接。这三个序列分别表示需要输入和输出以及发生异常（错误等）的连接。  
如果没有指定超时时间， select将阻断（即等待）到有文件描述符准备就绪；如果指定了超时时间， select将最多阻断指定的秒数；如果超时时间为零， select将不断轮询（即不阻断）。  
select返回三个序列（即一个长度为3的元组），其中每个序列都包含相应参数中处于活动状态的文件描述符。例如，返回的第一个序列包含有数据需要读取的所有输入文件描述符。

这些序列也可包含文件对象（Windows不支持）或套接字。下面的代码所示的服务器使用select来为多个连接提供服务。
（请注意，将服务器套接字传递给了select，让select能够在有新连接到来时发出信号。）这个服务器是一个简单的日志程序，将来自客户端的数据都打印出来。
```python
# 使用select的简单服务器
import socket, select
s = socket.socket()
host = socket.gethostname()
port = 1234
s.bind(host, port)
s.listen(5)
inputs = [s]
while True:
    # 参数的三个序列分别表示需要输入和输出以及发生异常（错误等）的连接。
    # 返回的每个序列都包含相应参数中处于活动状态的文件描述符。
    rs, ws, es = select.select(inputs, [], [])
    for r in rs:
        if r is s:
            c, addr = s.accept()
            print('Got connection from', addr)
            inputs.append(c)
    else:
        try:
            data = r.recv(1024)
            disconnected = not data
        except socket.error:
            disconnected = True
        if disconnected:
            print(r.getpeername(), 'disconnected')
            inputs.remove(r)
        else:
            print(data)
```
