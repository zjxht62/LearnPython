# 魔法方法、特性和迭代器

在Python中，以双下划线开始和结尾的方法很大一部分都是魔法方法（如__init__等)。如果你的对象实现了这些方法
，他们将在特性情况下（根据方法名不同而不同）被Python调用，而几乎不需要直接调用。

## 9.2 构造函数

构造函数将在对象创建后自动地被调用。

```python
class Foobar:
    def __init__(self):
        self.a = 42


f = Foobar()
print(f.a)  # 42
```

含参数的构造函数

```python
class Foobar:
    def __init__(self, a, content='我是默认内容'):
        self.a = a
        self.content = content


# f = Foobar() # TypeError: __init__() missing 1 required positional argument: 'a'

# 只传必要的位置参数a
f = Foobar(12)
print(f.a)  # 12
print(f.content)  # 我是默认内容

# 全传
f = Foobar(52, '哈哈')
print(f.a)  # 52
print(f.content)  # 哈哈
```

Python 不同于java 只能有一个构造函数，不支持通过参数重载

```python
# 如果定义了多个，会用最晚定义的那个
class Foobar:

    def __init__(self, value=42):
        self.somevar = value

    def __init__(self, value1, value2):
        self.somevar = value1
        self.somevar2 = value2

    def __init__(self):
        self.somevar = 45


f = Foobar()
print(f.somevar)  # 45
f = Foobar(
    99)  # TypeError: __init__() takes 1 positional argument but 2 were given
```

### 9.2.1 重写普通方法和特殊的构造函数

在执行子类的构造函数之前，往往需要先调用父类的构造函数，才能正确地初始化对象。 可以通过`super().__init__()`调用父类的构造函数

```python
class Bird:
    def __init__(self):
        self.hungry = True

    def eat(self):
        if self.hungry:
            print("吃吃吃")
            self.hungry = False
        else:
            print("老子不饿")


b = Bird()
b.eat()  # 吃吃吃
b.eat()  # 老子不饿


class SongBird(Bird):
    def __init__(self):
        # 调用父类的构造方法
        super().__init__()
        self.sound = '鸟叫'

    def sing(self):
        print(self.sound)


sb = SongBird()
sb.sing()  # 鸟叫
sb.eat()  # 吃吃吃
```

> 使用super的好处：即便有多个超类，也只需调用函数super一次（条件是所有超类的构造函数也使用函数super）。  
另外，对于使用旧式类时处理起来很棘手的问题（如两个超类从同一个类派生而来），在使用新式类和函数super时将自动得到处理。

## 9.3 元素访问

通过实现一些魔法方法，我们可以创建行为类似于序列或映射的对象

### 9.3.1 基本的序列和映射协议

序列和映射本质是元素的集合，要实现它们的基本行为（协议），不可变对象需要实现2个方法，可变对象需要实现4个。

+ `__len__(self)`:返回集合包含的项数，对于序列来说是元素个数，对映射来说是键值对数。如果__len__返回0，对象在布尔上下文中将视为假。
+ `__getitem__(self, key)`:返回与指定键关联的值。对序列来说，键应该是 0 ~
  n-1的整数（也可以是负数，这将在后面说明），其中n为序列的长度。对映射来说，键可以是任何类型
+ `__setitem(self, key, value)`:这个方法应以与键相关联的方式存储值，以便以后能够使用__getitem__
  来获取。当然，仅当对象可变时才需要实现这个方法。
+ `__delitem(self, key)`:在对象的组成部分使用__del__
  语句时被调用，应删除与key关联的值。同样，仅仅当对象是可变的，而且允许其中的项被删除时，才实现这个方法。

还有一些额外的要求。

+ 对于序列，如果键为整数，应从末尾往前数。换言之：x[-n] = x[len(x)-n]
+ 如果键的类型不合适（如对序列使用字符串键），可能引发TypeError异常
+ 对于序列，如果索引类型正确，但是不在允许范围内，应引发IndexError异常

实现一个算术序列，任何两个相邻的数字的差都相同

```python
def check_key(key):
    # 如果key的类型不对，应抛出TypeError
    if not isinstance(key, int):
        raise TypeError
    # 如果key的值不合法，应抛出IndexError
    if key < 0:
        raise IndexError


class ArithmeticSequence:

    def __init__(self, start=0, step=1):
        """
        初始化这个算术序列
        start -序列中的第一个值
        step -两个相邻值的差
        changed -一个字典，包含用户修改后的值
        """
        self.start = start
        self.step = step
        # 用一个字典保存修改的元素
        self.changed = {}

    def __getitem__(self, key):
        check_key(key)
        try:
            return self.changed[key]
        except KeyError:
            return self.start + key * self.step

    def __setitem__(self, key, value):
        check_key(key)
        self.changed[key] = value

    # 因为是无穷序列，所以没有实现__len__
    # 因为不允许进行修改，所以没实现__del__


arithmetic_seq = ArithmeticSequence(1, 2)
print(arithmetic_seq[0])  # 1
print(arithmetic_seq[1])  # 3
print(arithmetic_seq[2])  # 5
print(arithmetic_seq[3])  # 7
print(arithmetic_seq[4])  # 9
arithmetic_seq[4] = 999
print(arithmetic_seq[4])  # 999
```

### 9.3.2 从list、dict和str派生

上面的四个基本的序列、映射的方法可以让你走很远，但是还有很多其他的魔法方法和普通方法。将他们全部实现的话，工作量会很大而且难度不小。
在标准库里，模块collections提供了抽象和具体的基类，也可以继承内置类型。

实现一个带访问计数器的列表

```python
class CounterList(list):
    def __init__(self, *args):
        super().__init__(*args)
        self.counter = 0

    def __getitem__(self, index):
        self.counter += 1
        return super().__getitem__(index)


cl = CounterList(range(10))
print(cl)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(cl.counter)  # 0
print(cl[4] + cl[2])  # 6
print(cl.counter)  # 2 调用了两次__getitem__方法
```

## 9.4 其他魔法方法

有很多的魔法方法前面的只是冰山一角。魔法方法是为高级用途准备的。  
各种魔法方法可以参考：https://docs.python.org/3/reference/datamodel.html#special-method-names

## 9.5 特性

Python能够替你隐藏存取方法，让所有的属性看起来都一样。通过存取方法定义的属性通常称为特性（property）。

### 9.5.1 函数property

```python
# 使用property函数，能够让我们将存取方法和直接访问属性绑定起来，实现在用.获取和设置属性时进行校验等操作
class Rectangle():
    def __init__(self):
        self.width = 0
        self.height = 0

    def getSize(self):
        print('我是getSize方法，我被调用了')
        return self.width, self.height

    def setSize(self, size):
        print('我是setSize方法，我被调用了')
        self.width, self.height = size

    size = property(getSize, setSize)


r = Rectangle()
r.width = 10
r.height = 5

print(r.size)  # (10, 5)
r.size = 150, 100
print(r.width)  # 150
```

调用函数property时，还可不指定参数、指定一个参数、指定三个参数或指定四个参数。  
如果没有指定任何参数，创建的特性将既不可读也不可写。  
如果只指定一个参数（获取方法），创建的特性将是只读的。  
第三个参数是可选的，指定用于删除属性的方法（这个方法不接受任何参数）。  
第四个参数也是可选的，指定一个文档字符串。  
这些参数分别名为fget、fset、 fdel和doc。如果你要创建一个只可写且带文档字符串的特性，可使用它们作为关键字参 数来实现

### 9.5.2 静态方法和类方法

静态方法的定义中没有参数self，可直接通过类来调用。  
类方法的定义中包含类似于self的参数，通常被命名为cls。对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。

```python
class MyClass:

    @staticmethod
    def staticMehtod():
        print('我是静态方法')

    @classmethod
    def classMethod(cls):
        print('我是类方法', cls)


# 无需实例化对象，直接通过类来调用
MyClass.staticMehtod()  # 我是静态方法
MyClass.classMethod()  # 我是类方法 <class '__main__.MyClass'>
```

静态方法的用武之地（静态工厂）

```python
class Bike:
    def __init__(self, name):
        self.name = name


class MountainBike(Bike):
    def __init__(self):
        super(MountainBike, self).__init__("山地车")


class RoadBike(Bike):
    def __init__(self):
        super(MountainBike, self).__init__("公路车")


class BikeFactory:
    @staticmethod
    def make_bike(type):
        if type == 0:
            return MountainBike()
        elif type == 1:
            return RoadBike()


bike = BikeFactory.make_bike(0)
print(type(bike))  # <class '__main__.MountainBike'>
print(bike.name)  # 山地车
```

### 9.5.3 __getattr__  __setattr__等方法

这些方法可以拦截对对象属性的所有访问企图，用途之一就是在旧式类中实现特性（在旧式类中，函数property的行为可能不符合预期）。要在属性被访问时执行一段代码，必须使用一些魔法方法。

```python
class Rectangle:
    def __init__(self):
        self.width = 0
        self.height = 0

    def __setattr__(self, key, value):
        if key == 'size':
            self.width, self.height = value
        else:
            self.__dict__[key] = value

    def __getattr__(self, item):
        if item == 'size':
            return self.width, self.height
        else:
            raise AttributeError()
```

## 9.6 迭代器

### 9.6.1 迭代器协议

迭代意味着重复多次，就像循环那样。可以迭代那些实现了方法`__iter__`的对象。    
`__iter__`方法返回一个迭代器对象，它包含方法`__next__`
，调用这个方法的时候，迭代器应返回下一个值。如果没有可提供的值，应引发StopIteration异常。

为何使用迭代器而不是使用列表呢？  
有时可能需要逐个获取值，而使用列表的话，如果值很多的话，就会占用大量内存。同时：使用迭代器更通用，更简单、更优雅。

```python
class Fibs:
    def __init__(self):
        self.a = 0
        self.b = 1

    def __iter__(self):
        return self

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        return self.a


fibs = Fibs()
for f in fibs:
    if f > 1000:
        print(f)  # 1597
        break
```

> 更正规的定义是，实现了方法__iter__的对象是可迭代的，而实现了方法__next__的对象 是迭代器。

### 9.6.2 从迭代器创建序列

除了对迭代器和可迭代对象进行迭代之外，还可以将他们转换为序列。在可以使用序列的情况下，大多也可以使用迭代器或可迭代对象（诸如索引和切片等操作除外）。  
一个例子是使用构造函数list显式地将迭代器转换为列表。

```python
class TestIterator:
    value = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.value += 1
        if self.value > 10:
            raise StopIteration
        return self.value


ti = TestIterator()
print(list(ti))  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

## 9.7 生成器

生成器是Python里面一个新引入的概念。  
生成器是一种使用普通函数语法定义的迭代器。

### 9.7.1 创建生成器

创建一个将嵌套列表展开的函数

```python
nested = [[1, 2], [3, 4], [5]]


def flatten(nested):
    for sublist in nested:
        for ele in sublist:
            yield ele


print(list(flatten(nested)))  # [1, 2, 3, 4, 5]
```

包含yield语句的函数都被称为生成器。生成器的行为与普通函数截然不同，差别在于，生成器不是
通过return返回一个值，而是通过yield生成多个值，每次一个。每次使用yield生成一个值之后，
函数都会冻结，即在此停止执行，等待不被重新唤醒。被重新唤醒后，函数将从停止的地方开始继续执行。

----------------

### 简单生成器

Python2.4中，引入了一个类似于列表推导的概念：生成器推导（也叫生成器表达式）。
工作原理和列表推导相同，但不是创建一个对象，而是返回一个生成器，让用户可以逐步执行运算。

```python
g = ((i + 2) ** 2 for i in range(2, 27))
next(g)  # 16
next(g)  # 25
next(g)  # 36
```

不同于列表推导，这里使用的是圆括号。如果要包装可迭代对象（可能生成大量的值），使用列表推 导将立即实例化一个列表，从而丧失迭代的优势。
另一个好处是。直接在一对既有的圆括号内（如函数调用里）使用生成器推导时，无需再添加一对括号。 换言之，可以编写像下面这样的代码。

```python
sum(i ** 2 for i in range(10))
# 0 + 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 = 285
```

----------------

### 9.7.2 递归式生成器

使用递归式生成器来展开嵌套列表  
基线条件：被展开的对象是单个元素。for循环将引发TypeError异常，而这个生成器只生成一个元素。  
递归条件：如果要展开的是一个列表（或其他任何可迭代对象），需要工作：遍历所有的子列表（其中有些可能并不是列表）并对它们调用flatten，然后使用另一个for循环生成展开后的子列表中的所有元素。

```python
def flatten(nested):
    try:
        for sublist in nested:
            for element in flatten(sublist):
                yield element
    except TypeError:
        yield nested
```

如果nested是字符串或类似于字符串的对象，它就属于序列，因此不会引发TypeError异常，可你并不想对其进行迭代。

```python
# 在开头通过异常检查对象是否是类似字符串的对象
def flatten(nested):
    try:
        # 不迭代类似于字符串的对象：
        try:
            nested + ''
        except TypeError:
            pass
        else:
            raise TypeError
        for sublist in nested:
            for element in flatten(sublist):
                yield element
    except TypeError:
        yield nested
```

如果表达式nested + ''引发了TypeError异常，就忽略这种异常；如果没有引发TypeError异常
，内部try语句中的else子句将引发TypeError异常，这样将在外部的excpet子句中原封不动地生成类似于字符串的对象。

### 9.7.3 通用生成器

生成器是包含关键字yield的函数，但是调用时不会执行函数体内的代码，而是返回一个迭代器。
每次请求值的时候，都将执行生成器的代码，直到遇到yield或return。yield意味着生成一个值，return代表停止执行。  
换而言之，生成器由两个单独的部分组成： `生成器的函数`和`生成器的迭代器`
。生成器的函数时由def定义的，其中包含yield。生成器的迭代器是这个函数返回的结果。 用不太准确的话说，这两个实体通常被视为一个，统称为生成器。

```python
>> >

def simple_generator():


    yield 1
...
>> > simple_generator
< function
simple_generator
at
153
b44 >
>> > simple_generator()
< generator
object
at
1510
b0 >
```

对于生成器的函数返回的迭代器，可以像使用其他迭代器一样使用它。

### 9.7.4 生成器的方法

在生成器开始运行后，可使用生成器和外部之间的通信渠道向它提供值。这个通信渠道包含如下两个端点。

+ 外部世界：外部世界可访问生成器的方法send，这个方法类似于next，但接受一个参数（要发送的“消息”，可以是任何对象）
+ 生成器：在挂起的生成器内部，yield可能用作表达式而不是语句。

换而言之，当生成器重新运行时，
yield返回一个值——通过send从外部世界发送的值。如果使用的是next，yield将返回None。请注意，仅当生成器被挂起（即遇到第一个yield）后，使用send（而不是next）才有意义。要在此之前向生成器提供信息，可使用生成器的函数的参数。
> 如果一定要在生成器刚启动时对其调用方法send，可向它传递参数None

```python
def repeater(value):
    while True:
        new = (yield value)
        if new is not None: value = new

# 下面使用了这个生成器：
>> > r = repeater(42)
>> > next(r)
42
>> > r.send("Hello, world!")
"Hello, world!
```

生成器还包含另外两个方法。

+ 方法throw：用于在生成器中（yield表达式处）引发异常，调用时可提供一个异常类型、一个可选值和一个traceback对象。
+ 方法close：用于停止生成器，调用时无需提供任何参数。

方法close（由Python垃圾收集器在需要时调用）也是基于异常的：在yield处引发GeneratorExit异常。因此如果要在生成器中提供一些清理代码，可将yield放在一条try/finally语句中。如果愿意，也可捕获GeneratorExit异常，但随后必须重新引发它（可能在清理后）、引发其他异常或直接返回。对生成器调用close后，再试图从它那里获取值将导致RuntimeError异常。

## 八皇后问题

### 9.8.1 生成器的回溯

对于逐步得到结果的复杂递归算法，非常适合使用生成器来实现。

### 9.8.2 问题

描述，将8个皇后放在8*8的棋盘上，任何一个皇后都不能威胁其他皇后（不能在同一行或同一列，也不能在一条对角线上）

### 9.8.3 状态表示

使用元组来表示可能的解（或其一部分），其中每个元素的值表示皇后所在的列。比如state[0]=3，说明皇后在第1行，第4列。
在特定的递归层级（也就是特定的行），你只知道上面各皇后的位置，因此状态元组的长度小于8（即皇后总数）

### 9.8.4 检测冲突

```python
# nextX表示下一个元素的x坐标（即列），nextY表示下一个元素的y坐标（即行）
def conflict(state, nextX):
    nextY = len(state)
    for i in range(len(state)):
        # 如果下一个皇后和当前皇后的水平距离为0（在同一列）或与它们的垂直距离相等（位于一条对角线上），这个表达式就为真
        if abs(state[i] - nextX) in (0, nextY - i):
            return True
    return False
```

### 9.8.5 基线条件

下面先来看基线条件：最后一个皇后。对于这个皇后，你想如何处理呢？假设你想找出所有
可能的解——给定其他皇后的位置，可将这个皇后放在什么位置（可能什么位置都不行）？可以 这样编写代码。

```python
def queens(num, state):
    if len(state) == num -1:
        for pos in range(num):
            if not conflict(state, pos):
                yield pos
```
如果只剩下最后一个皇后没有放好，就遍历所有可能的位置，并返回那
些不会引发冲突的位置。参数num为皇后总数，而参数state是一个元组，包含已放好的皇后的位
置

### 9.8.6 递归条件
```python
...
# 如果不是最后一个皇后
else:
    for pos in range(num):
        if not conflict(state, pos):
            for result in queens(num, state + (pos,)):
                yield (pos,) +result
```
```python
# 最终版
def queens(num=8, state=()):
  for pos in range(num):
    if not conflict(state, pos):
      if len(state) == num-1:
        yield (pos,)
      else:
        for result in queens(num, state + (pos,)):
          yield (pos,) + result

print(list(queens(4)))  # [(1, 3, 0, 2), (2, 0, 3, 1)]
```
### 9.8.7 扫尾工作
```python
def prettyprint(solution):
    def line(pos, length=len(solution)):
        return '. ' * (pos) + 'X ' + '. ' * (length-pos-1)
    for pos in solution:
        print(line(pos))
```