# 魔法方法、特性和迭代器

在Python中，以双下划线开始和结尾的方法很大一部分都是魔法方法（如__init__等)。如果你的对象实现了这些方法
，他们将在特性情况下（根据方法名不同而不同）被Python调用，而几乎不需要直接调用。

## 9.2 构造函数

构造函数将在对象创建后自动地被调用。

```python
class Foobar:
    def __init__(self):
        self.a = 42


f = Foobar()
print(f.a)  # 42
```

含参数的构造函数

```python
class Foobar:
    def __init__(self, a, content='我是默认内容'):
        self.a = a
        self.content = content


# f = Foobar() # TypeError: __init__() missing 1 required positional argument: 'a'

# 只传必要的位置参数a
f = Foobar(12)
print(f.a)  # 12
print(f.content)  # 我是默认内容

# 全传
f = Foobar(52, '哈哈')
print(f.a)  # 52
print(f.content)  # 哈哈
```

Python 不同于java 只能有一个构造函数，不支持通过参数重载

```python
# 如果定义了多个，会用最晚定义的那个
class Foobar:

    def __init__(self, value=42):
        self.somevar = value

    def __init__(self, value1, value2):
        self.somevar = value1
        self.somevar2 = value2

    def __init__(self):
        self.somevar = 45


f = Foobar()
print(f.somevar)  # 45
f = Foobar(
    99)  # TypeError: __init__() takes 1 positional argument but 2 were given
```

### 9.2.1 重写普通方法和特殊的构造函数

在执行子类的构造函数之前，往往需要先调用父类的构造函数，才能正确地初始化对象。 可以通过`super().__init__()`调用父类的构造函数

```python
class Bird:
    def __init__(self):
        self.hungry = True

    def eat(self):
        if self.hungry:
            print("吃吃吃")
            self.hungry = False
        else:
            print("老子不饿")


b = Bird()
b.eat()  # 吃吃吃
b.eat()  # 老子不饿


class SongBird(Bird):
    def __init__(self):
        # 调用父类的构造方法
        super().__init__()
        self.sound = '鸟叫'

    def sing(self):
        print(self.sound)


sb = SongBird()
sb.sing()  # 鸟叫
sb.eat()  # 吃吃吃
```

> 使用super的好处：即便有多个超类，也只需调用函数super一次（条件是所有超类的构造函数也使用函数super）。  
另外，对于使用旧式类时处理起来很棘手的问题（如两个超类从同一个类派生而来），在使用新式类和函数super时将自动得到处理。

## 9.3 元素访问

通过实现一些魔法方法，我们可以创建行为类似于序列或映射的对象

### 9.3.1 基本的序列和映射协议

序列和映射本质是元素的集合，要实现它们的基本行为（协议），不可变对象需要实现2个方法，可变对象需要实现4个。

+ `__len__(self)`:返回集合包含的项数，对于序列来说是元素个数，对映射来说是键值对数。如果__len__返回0，对象在布尔上下文中将视为假。
+ `__getitem__(self, key)`:返回与指定键关联的值。对序列来说，键应该是 0 ~
  n-1的整数（也可以是负数，这将在后面说明），其中n为序列的长度。对映射来说，键可以是任何类型
+ `__setitem(self, key, value)`:这个方法应以与键相关联的方式存储值，以便以后能够使用__getitem__
  来获取。当然，仅当对象可变时才需要实现这个方法。
+ `__delitem(self, key)`:在对象的组成部分使用__del__
  语句时被调用，应删除与key关联的值。同样，仅仅当对象是可变的，而且允许其中的项被删除时，才实现这个方法。

还有一些额外的要求。

+ 对于序列，如果键为整数，应从末尾往前数。换言之：x[-n] = x[len(x)-n]
+ 如果键的类型不合适（如对序列使用字符串键），可能引发TypeError异常
+ 对于序列，如果索引类型正确，但是不在允许范围内，应引发IndexError异常

实现一个算术序列，任何两个相邻的数字的差都相同

```python
def check_key(key):
    # 如果key的类型不对，应抛出TypeError
    if not isinstance(key, int):
        raise TypeError
    # 如果key的值不合法，应抛出IndexError
    if key < 0:
        raise IndexError


class ArithmeticSequence:

    def __init__(self, start=0, step=1):
        """
        初始化这个算术序列
        start -序列中的第一个值
        step -两个相邻值的差
        changed -一个字典，包含用户修改后的值
        """
        self.start = start
        self.step = step
        # 用一个字典保存修改的元素
        self.changed = {}

    def __getitem__(self, key):
        check_key(key)
        try:
            return self.changed[key]
        except KeyError:
            return self.start + key * self.step

    def __setitem__(self, key, value):
        check_key(key)
        self.changed[key] = value

    # 因为是无穷序列，所以没有实现__len__
    # 因为不允许进行修改，所以没实现__del__


arithmetic_seq = ArithmeticSequence(1, 2)
print(arithmetic_seq[0])  # 1
print(arithmetic_seq[1])  # 3
print(arithmetic_seq[2])  # 5
print(arithmetic_seq[3])  # 7
print(arithmetic_seq[4])  # 9
arithmetic_seq[4] = 999
print(arithmetic_seq[4])  # 999
```

### 9.3.2 从list、dict和str派生

上面的四个基本的序列、映射的方法可以让你走很远，但是还有很多其他的魔法方法和普通方法。将他们全部实现的话，工作量会很大而且难度不小。
在标准库里，模块collections提供了抽象和具体的基类，也可以继承内置类型。

实现一个带访问计数器的列表

```python
class CounterList(list):
    def __init__(self, *args):
        super().__init__(*args)
        self.counter = 0

    def __getitem__(self, index):
        self.counter += 1
        return super().__getitem__(index)


cl = CounterList(range(10))
print(cl)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(cl.counter)  # 0
print(cl[4] + cl[2])  # 6
print(cl.counter)  # 2 调用了两次__getitem__方法
```

## 9.4 其他魔法方法

有很多的魔法方法前面的只是冰山一角。魔法方法是为高级用途准备的。  
各种魔法方法可以参考：https://docs.python.org/3/reference/datamodel.html#special-method-names

## 9.5 特性

Python能够替你隐藏存取方法，让所有的属性看起来都一样。通过存取方法定义的属性通常称为特性（property）。

### 9.5.1 函数property

```python
# 使用property函数，能够让我们将存取方法和直接访问属性绑定起来，实现在用.获取和设置属性时进行校验等操作
class Rectangle():
    def __init__(self):
        self.width = 0
        self.height = 0

    def getSize(self):
        print('我是getSize方法，我被调用了')
        return self.width, self.height

    def setSize(self, size):
        print('我是setSize方法，我被调用了')
        self.width, self.height = size

    size = property(getSize, setSize)


r = Rectangle()
r.width = 10
r.height = 5

print(r.size)  # (10, 5)
r.size = 150, 100
print(r.width)  # 150
```

调用函数property时，还可不指定参数、指定一个参数、指定三个参数或指定四个参数。  
如果没有指定任何参数，创建的特性将既不可读也不可写。  
如果只指定一个参数（获取方法），创建的特性将是只读的。  
第三个参数是可选的，指定用于删除属性的方法（这个方法不接受任何参数）。  
第四个参数也是可选的，指定一个文档字符串。  
这些参数分别名为fget、fset、 fdel和doc。如果你要创建一个只可写且带文档字符串的特性，可使用它们作为关键字参 数来实现

### 9.5.2 静态方法和类方法

静态方法的定义中没有参数self，可直接通过类来调用。  
类方法的定义中包含类似于self的参数，通常被命名为cls。对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。

```python
class MyClass:

    @staticmethod
    def staticMehtod():
        print('我是静态方法')

    @classmethod
    def classMethod(cls):
        print('我是类方法', cls)


# 无需实例化对象，直接通过类来调用
MyClass.staticMehtod()  # 我是静态方法
MyClass.classMethod()  # 我是类方法 <class '__main__.MyClass'>
```

静态方法的用武之地（静态工厂）

```python
class Bike:
    def __init__(self, name):
        self.name = name


class MountainBike(Bike):
    def __init__(self):
        super(MountainBike, self).__init__("山地车")


class RoadBike(Bike):
    def __init__(self):
        super(MountainBike, self).__init__("公路车")


class BikeFactory:
    @staticmethod
    def make_bike(type):
        if type == 0:
            return MountainBike()
        elif type == 1:
            return RoadBike()


bike = BikeFactory.make_bike(0)
print(type(bike))  # <class '__main__.MountainBike'>
print(bike.name)  # 山地车
```

### 9.5.3 __getattr__  __setattr__等方法

这些方法可以拦截对对象属性的所有访问企图，用途之一就是在旧式类中实现特性（在旧式类中，函数property的行为可能不符合预期）。要在属性被访问时执行一段代码，必须使用一些魔法方法。

```python
class Rectangle:
    def __init__(self):
        self.width = 0
        self.height = 0

    def __setattr__(self, key, value):
        if key == 'size':
            self.width, self.height = value
        else:
            self.__dict__[key] = value

    def __getattr__(self, item):
        if item == 'size':
            return self.width, self.height
        else:
            raise AttributeError()
```



