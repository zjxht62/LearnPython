# 抽象
## 6.1 懒惰是一种美德
```python
#计算前十个斐波那契数列
fib = [0, 1]
for i in range(8):
    fib.append(fib[-2] + fib[-1])
print(fib) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
通过抽象，可以减少重复的代码
```python
num = input('How many numbers do you want?')
print(fibs(num))
```
## 6.2 抽象和结构
抽象是程序能够被人理解的关键所在：通过函数名，参数名，人们能理解函数的用途和用法。而不必关心其实现细节。

## 6.3 自定义函数
函数执行特定的操作并返回一个值。可以在调用的时候传入参数。

可以通过callable判断对象是否可调用
```python
import math

x = 1
y = math.sqrt
print(callable(x))  # False
print(callable(y))  # True
```
定义函数(使用关键词 `def`)
```python
# 定义函数
def hello(name):
    return 'hello ' + name
print(hello("zjx"))
```
封装后的斐波那契数列函数
```python
def fibs(num):
    result = [0, 1]
    for i in range(num - 2):
        result.append(result[-2] + result[-1])
    return result

print(fibs(20))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]

```
### 6.3.1 给函数编写文档
放在函数开头的字符串称为`文档字符串（docstring）`
```python
def haha():
    """就是打印哈哈而已"""
    print('哈哈 ')

print(haha.__doc__)  # 就是打印哈哈而已
```
> __doc__是函数的一个属性。属性中的双下划线代表这是一个特殊的属性。

在交互式解释器里，可以使用help函数获取函数的信息
```python
>>> help(square)
Help on function square in module __main__:
square(x)
Calculates the square of the number x.
```
### 6.3.2 其实不是函数的函数
Python的函数可以不包含return语句，或者return后不指定值。但是，所有的函数都有返回值，如果不告诉函数返回什么，那么就返回None。
```python
def test():
    print('just a test')
    return
    print('another test')

x = test()  # 打印出 just a test
print(x)  # None
```
> 不要让这种默认行为带来麻烦。如果你在if之类的语句中返回值，务必确保其他分支也
返回值，以免在调用者期望函数返回一个序列时（举个例子），不小心返回了None。
## 6.4 参数魔法
### 6.4.1 值从哪里来
值是由调用方传入的，函数定义时的变量称为形参，调用函数时提供的值称为实参
### 6.4.2 对参数的修改
在函数内部给参数赋值对外部没有任何影响
```python
list = [1, 2, 3]
def replaceList(n):
    n = [4, 5, 6]

replaceList(list)
print(list)  # [1, 2, 3]
```
在函数内对可变的数据结构（如列表）进行修改，那么就会影响对应的变量
```python
list = ['嘿嘿', '呵呵']
def changeList(n):
    n[0] = '哈哈'

changeList(list)
print(list)  # ['哈哈', '呵呵']
```
> 如果不想让函数改变列表的值，可以使用切片操作，切片操作返回的是列表的副本，所以可以创建整个列表的切片。
> ```python
> names = [zjx, ckx]
> n = names[:]
> n is names # False
> n == names # True
>```
1. 为何要修改参数  

通过函数来修改数据结构可以提高抽象程度
   
```python
def init(data):
    data['first'] = {}
    data['middle'] = {}
    data['last'] = {}


def lookup(data, label, name):
    return data[label].get(name)


def store(data, fullName):
    names = fullName.split()
    if len(names) == 2:
        names.insert(1, "")
    labels = 'first', 'middle', 'last'
    for label, name in zip(labels, names):
        people = lookup(data, label, name)
        if people:
            people.append(fullName)
        else:
            data[label][name] = [fullName]


mybook = {}
init(mybook)
store(mybook, 'Zhao Jixiang')
store(mybook, 'Da Chou Bao')
print(lookup(mybook, 'middle', ''))
```
2. 如果参数是不可变的

Python不像C++等语言，可以给参数赋值并让这种修改影响到外部变量。  
在Python里，只能修改参数对象本身。如果需要对外部变量进行修改，那么需要将修改后的变量返回，并赋值给外部变量。
```python
def inc(x):
    return x + 1

foo = 10
foo = inc(foo)
foo # 11
```
### 6.4.3 关键字参数和默认值
位置参数
```python
def hello_1(greeting, name):
    print(f'{greeting}, {name}')
hello_1('你好啊', '陌生人')
```
关键字参数
```python
# 在调用函数的时候可以指定关键字参数，就不用关系顺序了
hello_1(name='赵吉祥', greeting='吃了吗')

# 其他例子
store(patient='Mr. Brainsample', hour=10, minute=20, day=13, month=5)
```
关键字参数最大的优点在于，可以在定义函数时指定默认值。
```python
def hello3(greeting='你好', name='世界'):
    print(f'{greeting}, {name}')

# 在调用时不提供，就会使用默认值
hello3() # 你好, 世界

hello3('吃了吗') # 吃了吗, 世界

hello3('吃了吗', '您') # 吃了吗, 您

hello3(name='陌生人') # 你好, 陌生人
```
可结合使用位置参数和关键字参数，但必须先指定所有的位置参
数，否则解释器将不知道它们是哪个参数（即不知道参数对应的位置）。
> 通常不应结合使用位置参数和关键字参数，除非你知道这样做的后果。一般而言，除非
必不可少的参数很少，而带默认值的可选参数很多，否则不应结合使用关键字参数和位
置参数。
```python
def hello_4(name, greeting='Hello', punctuation='!'):
    print('{}, {}{}'.format(greeting, name, punctuation))


hello_4('zjx') # Hello, zjx!
hello_4('Mars', 'Howdy') # Howdy, Mars!
hello_4('Mars', 'Howdy', '...') # Howdy, Mars...
hello_4('zjx', punctuation='。') # Hello, zjx。
hello_4('zjx', greeting='吃了吗') # 吃了吗, zjx!
hello_4(greeting='吃了吗', name='赵吉祥') # 吃了吗, 赵吉祥!
hello_4()
# Traceback (most recent call last):
#   File "E:/zjx/PycharmProjects/LearnPython/BeginningPython/chapter6/chapter6.py", line 150, in <module>
#     hello_4()
# TypeError: hello_4() missing 1 required positional argument: 'name'
```