# 抽象

## 6.1 懒惰是一种美德

```python
# 计算前十个斐波那契数列
fib = [0, 1]
for i in range(8):
    fib.append(fib[-2] + fib[-1])
print(fib)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

通过抽象，可以减少重复的代码

```python
num = input('How many numbers do you want?')
print(fibs(num))
```

## 6.2 抽象和结构

抽象是程序能够被人理解的关键所在：通过函数名，参数名，人们能理解函数的用途和用法。而不必关心其实现细节。

## 6.3 自定义函数

函数执行特定的操作并返回一个值。可以在调用的时候传入参数。

可以通过callable判断对象是否可调用

```python
import math

x = 1
y = math.sqrt
print(callable(x))  # False
print(callable(y))  # True
```

定义函数(使用关键词 `def`)

```python
# 定义函数
def hello(name):
    return 'hello ' + name


print(hello("zjx"))
```

封装后的斐波那契数列函数

```python
def fibs(num):
    result = [0, 1]
    for i in range(num - 2):
        result.append(result[-2] + result[-1])
    return result


print(fibs(
    20))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]

```

### 6.3.1 给函数编写文档

放在函数开头的字符串称为`文档字符串（docstring）`

```python
def haha():
    """就是打印哈哈而已"""
    print('哈哈 ')


print(haha.__doc__)  # 就是打印哈哈而已
```

> __doc__是函数的一个属性。属性中的双下划线代表这是一个特殊的属性。

在交互式解释器里，可以使用help函数获取函数的信息

```python
>> > help(square)
Help
on
function
square in module
__main__:
square(x)
Calculates
the
square
of
the
number
x.
```

### 6.3.2 其实不是函数的函数

Python的函数可以不包含return语句，或者return后不指定值。但是，所有的函数都有返回值，如果不告诉函数返回什么，那么就返回None。

```python
def test():
    print('just a test')
    return
    print('another test')


x = test()  # 打印出 just a test
print(x)  # None
```

> 不要让这种默认行为带来麻烦。如果你在if之类的语句中返回值，务必确保其他分支也 返回值，以免在调用者期望函数返回一个序列时（举个例子），不小心返回了None。

## 6.4 参数魔法

### 6.4.1 值从哪里来

值是由调用方传入的，函数定义时的变量称为形参，调用函数时提供的值称为实参

### 6.4.2 对参数的修改

在函数内部给参数赋值对外部没有任何影响

```python
list = [1, 2, 3]


def replaceList(n):
    n = [4, 5, 6]


replaceList(list)
print(list)  # [1, 2, 3]
```

在函数内对可变的数据结构（如列表）进行修改，那么就会影响对应的变量

```python
list = ['嘿嘿', '呵呵']


def changeList(n):
    n[0] = '哈哈'


changeList(list)
print(list)  # ['哈哈', '呵呵']
```

> 如果不想让函数改变列表的值，可以使用切片操作，切片操作返回的是列表的副本，所以可以创建整个列表的切片。
> ```python
> names = [zjx, ckx]
> n = names[:]
> n is names # False
> n == names # True
>```

1. 为何要修改参数

通过函数来修改数据结构可以提高抽象程度

```python
def init(data):
    data['first'] = {}
    data['middle'] = {}
    data['last'] = {}


def lookup(data, label, name):
    return data[label].get(name)


def store(data, fullName):
    names = fullName.split()
    if len(names) == 2:
        names.insert(1, "")
    labels = 'first', 'middle', 'last'
    for label, name in zip(labels, names):
        people = lookup(data, label, name)
        if people:
            people.append(fullName)
        else:
            data[label][name] = [fullName]


mybook = {}
init(mybook)
store(mybook, 'Zhao Jixiang')
store(mybook, 'Da Chou Bao')
print(lookup(mybook, 'middle', ''))
```

2. 如果参数是不可变的

Python不像C++等语言，可以给参数赋值并让这种修改影响到外部变量。  
在Python里，只能修改参数对象本身。如果需要对外部变量进行修改，那么需要将修改后的变量返回，并赋值给外部变量。

```python
def inc(x):
    return x + 1


foo = 10
foo = inc(foo)
foo  # 11
```

### 6.4.3 关键字参数和默认值

位置参数

```python
def hello_1(greeting, name):
    print(f'{greeting}, {name}')


hello_1('你好啊', '陌生人')
```

关键字参数

```python
# 在调用函数的时候可以指定关键字参数，就不用关系顺序了
hello_1(name='赵吉祥', greeting='吃了吗')

# 其他例子
store(patient='Mr. Brainsample', hour=10, minute=20, day=13, month=5)
```

关键字参数最大的优点在于，可以在定义函数时指定默认值。

```python
def hello3(greeting='你好', name='世界'):
    print(f'{greeting}, {name}')


# 在调用时不提供，就会使用默认值
hello3()  # 你好, 世界

hello3('吃了吗')  # 吃了吗, 世界

hello3('吃了吗', '您')  # 吃了吗, 您

hello3(name='陌生人')  # 你好, 陌生人
```

可结合使用位置参数和关键字参数，但必须先指定所有的位置参 数，否则解释器将不知道它们是哪个参数（即不知道参数对应的位置）。
> 通常不应结合使用位置参数和关键字参数，除非你知道这样做的后果。一般而言，除非 必不可少的参数很少，而带默认值的可选参数很多，否则不应结合使用关键字参数和位 置参数。

```python
def hello_4(name, greeting='Hello', punctuation='!'):
    print('{}, {}{}'.format(greeting, name, punctuation))


hello_4('zjx')  # Hello, zjx!
hello_4('Mars', 'Howdy')  # Howdy, Mars!
hello_4('Mars', 'Howdy', '...')  # Howdy, Mars...
hello_4('zjx', punctuation='。')  # Hello, zjx。
hello_4('zjx', greeting='吃了吗')  # 吃了吗, zjx!
hello_4(greeting='吃了吗', name='赵吉祥')  # 吃了吗, 赵吉祥!
hello_4()
# Traceback (most recent call last):
#   File "E:/zjx/PycharmProjects/LearnPython/BeginningPython/chapter6/chapter6.py", line 150, in <module>
#     hello_4()
# TypeError: hello_4() missing 1 required positional argument: 'name'
```

### 6.4.4 收集参数

使用带*的参数，会将所有的值放在一个元组里面

```python
def print_params(*params):
    print(params)


print_params('哈哈', '呵呵', '嘿嘿')  # ('哈哈', '呵呵', '嘿嘿')
```

收集余下的位置参数

```python
def print_params_2(title, *params):
    print(title)
    print(params)


print_params_2('Params', 1, 2, 3)
# Params
# (1, 2, 3)

print_params_2('nothing')
# nothing
# ()
```

如果带*的参数不是在最后，需要使用名称来指定后续参数

```python
def inTheMiddle(x, *y, z):
    print(x, y, z)


inTheMiddle(1, 2, 3, 4, 5, 6, z=7)  # 1 (2, 3, 4, 5, 6) 7
```

*不会收集关键字参数

```python
def print_params_2(title, *params):
    print(title)
    print(params)


print_params_2('Hmm...', something=42)
# TypeError: print_params_2() got an unexpected keyword argument 'something'
```

可以使用**来收集关键字参数

```python
# 使用**来收集关键字参数，这将返回字典
def printParams3(title, **params):
    print(title, params)


printParams3("我是title", haha='哈哈', heihei='嘿嘿')
# 我是title {'haha': '哈哈', 'heihei': '嘿嘿'}
```

结合使用两种

```python
def print_params_4(x, y, z=3, *pospar, **keypar):
    print(x, y, z)
    print(pospar)
    print(keypar)


print_params_4(1, 2, 3, 5, 6, 7, foo=1, bar=2)

# 1 2 3
# (5, 6, 7)
# {'foo': 1, 'bar': 2}
```

### 6.4.5 分配参数

使用*和**也可以执行分配参数的操作。

```python
# 通过*和**也可以进行相反的操作，将元组和字典解构出来给函数
def add(x, y):
    return x + y


params = (1, 2)
print(add(*params))  # 3
print(add(*[1, 2]))  # 3


def hello3(greeting='你好', name='世界'):
    print(f'{greeting}, {name}')


params = {'name': 'Sir Robin', 'greeting': 'Well met'}
hello3(**params)  # Well met, Sir Robin
```

## 6.5 作用域

```python
# 内置函数var可以打印看不见的字典
x = 1
scope = vars()
# 取出x
print(scope['x'])  # 1
# 对x进行修改
scope['x'] += 1
print(x)  # 2
```

> 但是一般而言，不应该修改vars返回的字典，因为根据Python官方文档的说法，这样做的结果是不确定的。可能得不到想要的结果。

每个函数调用都将创建一个新的命名空间或作用域。

```python
def foo():
    x = 42


x = 1
foo()
x  # 1
```

可以在函数中访问全局变量，如果只是读取值（而不是重新关联它），通常不会有什么问题

```python
# 函数可以引用全局变量，但是可能导致bug，慎用
external = 'berry'


def combine(parameter):
    print(parameter + external)


combine("Shrub")  # Shrubberry
```

> 像这样访问全局变量是众多bug的根源。务必慎用全局变量。

----------
遮盖的问题。

在函数里读取全局变量也可能有问题，如果函数里有一个局部变量或参数名与要访问的全局变量同名。那么就无法直接访问全局变量，因为它被 局部变量给这盖住了。

如果需要，可以使用函数globals来访问全局变量。类似vars，它返回一个包含全局变量的字典（locals返回一个包含局部变量的字典。）

```shell
>>> def combine(parameter):
... print(parameter + globals()['parameter'])
...
>>> parameter = 'berry'
>>> combine('Shrub')
Shrubberry
```

-----------
重新关联变量是另外一回事儿，在函数内部给变量赋值的时候，该变量默认为局部变量，除非明确地告诉Python它是全局变量。

```python
# 全局变量
x = 2


def changeGlobal():
    # 告诉Pythonx是全局变量
    global x
    x = x + 1


changeGlobal()
print(x)  # 3
```

--------------------
作用域嵌套

一个函数位于另一个函数中，且外面的函数返回里面的函数。也就是返回一个 函数，而不是调用它。重要的是，返回的函数能够访问其定义所在的作用域。

```python
# 像multiplyByFactor这样存储其所在作用域的函数称为闭包。
def multipilier(factor):
    def multiplyByFactor(number):
        return number * factor

    return multiplyByFactor


double = multipilier(2)
print(double(5))

triple = multipilier(3)
print(triple(5))
```

## 6.6递归

递归意味着自己调用自己  
举个递归的例子：从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的是，前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的是。。。

递归通常包括下面两部分：

+ 基线条件（针对最小问题）：满足这种条件时函数将直接返回一个值。
+ 递归条件：包含一个或多个调用，这些调用旨在解决问题的一部分。

关键是，通过将问题分解为较小的部分，可避免递归没完没了，因为问题终将被分解 成基线条件可以解决的最小问题

### 6.6.1 两个景点案例：阶乘和幂

```python
# 非递归版本实现 求阶乘
def factorial(n):
    result = n
    for i in range(1, n):
        result = result * i
    return result


print(factorial(4))  # 24


# 递归实现阶乘
# 1的阶乘为1。
# 对于大于1的数字n，其阶乘为n-1的阶乘再乘以n。
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)


print(factorial(10))  # 3628800
```

```python
# 非递归 计算幂 
def power(x, n):
    result = 1
    for i in range(n):
        result *= x
    return result


print(power(2, 6))  # 64


# 递归计算幂
def power(x, n):
    if n == 0:
        return 1
    else:
        return x * power(x, n - 1)
```

在大多数情况 下，使用循环的效率可能更高。然而，在很多情况下，使用递归的可读性更高，且有时要高得多， 在你理解了函数的递归式定义时尤其如此。

### 6.6.2 另一个景点案例：二分查找

```python
# 二分查找
def search(sequence, number, lower=0, upper=None):
    if upper is None: upper = len(sequence) - 1
    if lower == upper:
        assert number == sequence[upper]
        return upper
    else:
        middle = (lower + upper) // 2
        if number > sequence[middle]:
            return search(sequence, number, middle + 1, upper)
        else:
            return search(sequence, number, lower, middle)
```

----------------
函数式编程

Python提供了一些有助于进行这种函数式编程的函数：map、filter和reduce。在较新的Python版本中，函数map和filter的用途并不大，应该使用列表推导来代替它们。
可以使用map将序列的所有元素传递给函数。

```python
>> > list(map(str, range(10)))  # 与[str(i) for i in range(10)]等价
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
```

你可使用filter根据布尔函数的返回值来对元素进行过滤。

```python
>> >

def func(x):


    ...
return x.isalnum()  # 检测字符串是否由字母和数字组成。
...
>> > seq = ["foo", "x41", "?!", "***"]
>> > list(filter(func, seq))
['foo', 'x41']
```

```python
# 如果采用列表推导，就无需自定义函数
[x for x in seq if x.isalnum()]
# ['foo', 'x41']
```

实际上， Python提供了一种名为lambda表达式的功能，让你能够创建内嵌的简单函数 （主要供map、 filter和reduce使用）。

```python
>> > filter(lambda x: x.isalnum(), seq)
['foo', 'x41']
```

函数reduce的功能：它使用指定的函数将序列的前两个元素合二为一，再将结果与第3个元素合二为 一，依此类推，直到处理完整个序列并得到一个结果。  
举例：将序列中的所有数字相加

```python
numbers = [1, 3, 5, 324, 25312, 12, 123, 543, 53, 4, 5]
from functools import reduce

a = reduce(lambda x, y: x + y, numbers)
print(a)  # 26385
```

## 6.7 小结
+ 抽象：抽象是隐藏细节的技术。通过定义函数，可以让程序更加抽象。
+ 函数定义：函数通过def关键字定义。函数始终会返回值，如果什么都都不指定，就返回None。
+ 参数：函数通过参数接收信息。Python中参数有两类：位置参数和关键字参数。通过给参数指定默认值，可以使它变成可选参数。
+ 作用域：变量存储在作用域（也叫命名空间）里。在Python中，作用域分两大类：全局作用域和局部作用域。作用域可以嵌套
+ 递归：函数可以调用自身。可使用递归完成的任务都可以使用循环来完成，但是有时递归的可读性更好。
+ 函数式编程：Python提供了一些函数式编程工具，其中包括lambda表达式以及函数map、filter和reduce。