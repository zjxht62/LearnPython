#第19章 趣味编程
这一章将介绍一些通用的Python编程指南。
## 19.1 为何要有趣
Python相比于其他编程语言来说，最大的特点就是非常高效。就是你能很快实现自己的想法。
## 19.2 编程柔术
柔指的是灵活性。在编程过程中遇到麻烦时，不要固收最初的设计和想法。而要灵活变通，以柔克刚。要做好适应变化的准备，
面对意外，不要气馁，去探索新选项和可能性。  
当你编写一个新程序的时候，可能是没有经验的，在逐渐实现的过程中，你会有新的认识。如果在你下次实现一个程序的时候，能够吸取之前一路走来的经验教训，
利用它们来重新设计（重构）既有软件，那软件的实现会更加完善。应该做好应对变化的心理准备，接受最初的设计肯定要修改的事实，
而不是在没有确定方向的情况下随意尝试。  
Python的灵活性涉及很多方面，下面是其中的两个：  
+ 原型设计：Python的优点之一就是可以让你快速地编写程序。所以当面临问题的时候，能够快速创建一个原型程序是很重要的。
+ 配置：配置旨在让程序的某些方面改动起来更加容易。  

第三个方面是自动化测试，要想轻松地修改程序，这必不可少。有了测试，你就可以在修改程序后，通过测试来确保程序的逻辑正确。
# 19.3 原型设计
在使用Python编程的时候，如果想搞懂某些地方的工作原理，可以尝试使用它。对于Python来说，可以直接运行代码，而不用像众多其他语言那样需要编译或链接操作。
不仅如此，还可以在Python交互式解释器内运行代码片段，来研究明白代码的工作原理。  
这种探索不限于语言或内置函数。更重要的是它可以轻松地创建程序原型，以便了解其工作原理。
> 注意 在这里，原型（prototype）指的是尝试性实现，即一个模型。它实现了最终程序的主要功能，但是在后期可能需要重写。通常，最初的原型都能变成可行的程序。

在对程序的结构（有哪些类和函数）有了想法之后，可以实现一个功能有限的简单版本。当你完成了一个可运行的程序之后，就会发现之后的工作容易得多。你可以添加新功能，
修改不喜欢的方面，等等。而不是只是在纸上画画草图。  
无论使用什么编程语言，都可以进行原型设计，但Python的优点在于，使用它编写原型的投入很少，因此完全可以弃之不用。但是如果使用C++等编程语言，编写原型的工作量会大很多，
到时候可能会舍不得将原型弃掉。  
在开发原型的时候，重要的是可以看到程序的各种缺陷。基于这些新的认识，再次尝试解决新的问题。
> 不要推到重来  
> 虽然提倡使用原型，但是当你考虑推倒重来的时候，要谨慎。如果你在编写原型的时候已经花费了大量的时间和精力，那么更要谨慎。更好的选择是对原型进行重构和修改，
> 让其变成功能上更好的系统，其原因有多个。  
> 一个可能出现的常见问题是"第二综合征"，即力图让第二个版本完美无缺，导致永远没有完工的时候。  
> "不断重写综合证"，指的是不断修改程序，甚至推倒重来。有时候我们需要的只是"还行"的程序----管用就好。  
> 还有“代码疲劳症”，即你对代码逐渐感到厌烦。你花了很长时间来编写代码，却发现它丑陋而笨拙。导致代码看起来粗糙而笨拙的原因之一是，必须处理各种特殊情况并包含多种形式的错误处理等。无论如何，在新版本中也必须包含这些功能，而最初为了实现它们， 你可能花了很大的精力(更别说为调试花费的精力了)。  
> 换言之，如果你觉得原型还有救，能变成可行的系统，那么应该竭尽所能地修改它，而不是推到重来。

# 19.4 配置
之前我们通过函数和类来提高了代码的抽象程度。下面还有一种更简单的提高程序抽象程度的方式：提取代码中的符号常量。  
## 19.4.1 提取常量
所谓常量，指的是内置字面量值，如数、字符串和列表。对于这些变量，可以将其存储在全局变量中。而且这些变量不会被修改，所以不会产生全局变量被修改时的影响。
一般常量的命名规则是：只在变量名中使用大写字母并用下划线分隔单词。
## 19.4.2 配置文件
虽然可以为了自己方便而提取常量，但是有时常量必须暴露给用户。有时需要由用户决定某些配置，比如连接数据库的地址和程序的默认行为等。  
可以将这些配置变量放在独立的文件中，而不是将它们放在模块开头。最简单的方法是：创建一个模块，专门用来存储变量
```python
# config.py
PI = 3.14
```
```python
from config import PI
```
这样，如果要修改PI的值，只需编辑config.py，而不用在代码中搜索。
> 警告  
> 使用配置文件有利有弊。一方面，配置很有用；但另一方面，使用针对整个项目的中央共享变量库可能降低项目的模块化程度（即增加耦合度）。因此，使用配置文件的时候，
> 务必不要破坏抽象（如封装）。

另一种方式是使用标准库模块configparser，从而可以从配置文件中使用标准格式。这样既可使用Python标准赋值语法，如下所示(这将在字符串中添加两个多余的引号):
```text
greeting = "Hello, world!"
```
也可使用很多程序都采用的另一种配置格式:
```text
greeting: Hello, world!
```
必须使用[files]、[colors]等标题将配置文件分为几个部分（section）。标题的名称可以随便指定，但必须将它们用方括号括起来。  
下面是一个简单的配置文件，和一个使用该配置文件的程序。
```ini
[numbers]
pi:3.1415926535897931

[message]

greeting: Welcome to the area calculation program! 
question: Please enter the radius:
result_message: The area is
```
```python
from configparser import ConfigParser

CONFIGFILE = 'area.ini'

config = ConfigParser()
# 读取配置文件
config.read(CONFIGFILE)

# 打印默认问候语(greeting):
# 在messages部分查找问候语:
print(config['messages'].get('greeting'))

# 使用配置文件中的提示（question）让用户输入半径：
radius = float(input(config['messages'].get('question') + " "))

# 打印配置文件中的结果消息（result_message）；
# 以空格结束以便接着在当前行打印：
print(config['messages'].get('result_message'), end=" ")

# getfloat()将获取的值转换为浮点数：
print(config['numbers'].getfloat('pi') * radius ** 2)
```
在设计程序时，要考虑哪些实现为可配置的。这样，可以让用户根据自己的偏好修改程序，让程序运行时按照用户希望的方式行事。
> 配置的级别  
> 在《UNIX编程艺术》中，描述了配置或控制信息的如下三个来源，应该按照这里的排序顺序查询这些来源，让后面的来源覆盖前面的来源。  
> + 配置文件
> + 环境变量：可使用字典os.environ来获取它们
> + 在命令行中向程序传递的开关和参数：要处理命令行参数，可以直接使用sys.argv；要处理开关（选项），应该使用模块argparse。

## 19.5 日志
日志可以帮你在程序中打印信息，发现问题换bug。日志大致上就是收集与程序运行相关的数据，供你事后进行研究和积累。print语句是一种简单的日志形式。
要使用这种日志形式，只需在程序开头包含一条类似下面的语句：  
```python
log = open('logfile.txt', 'w')
```
然后可以将任何感兴趣的程序状态信息写入这个文件。
```python
print("Downloading file from URL", url, file=log)
text = urllib.urlopen(url).read()
print'File successfully downloaded', file=log)
```
但是如果程序在下载期间崩溃，那么由于并没有及时关闭文件，所以文件内容是空的。这种方法的效果不好，更安全的做法是，在每条日志语句前后都打开和关闭文件，
至少应该在写入后刷新文件。这样即使程序崩溃，也能看到第一行"Downloading file from URL"出现在日志文件中，从而知道下载失败了。  
实际上，正确的做法是使用标准库中的模块logging。这个模块的基本用法非常简单。下面是一个例子：
```python
# 使用Python标准库模块logging
import logging
logging.basicConfig(level=logging.INFO, filename='mylog.log')
logging.info('Starting program')
logging.info('Trying to divide 1 by 0')
print(1/0)
logging.info('The division succeeded')
logging.info('Ending program')
```
运行上面的程序时，将生成一个名为`mylog.log`的日志文件
```text
INFO:root:Starting program
INFO:root:Trying to divide 1 by 0
```
上面的日志指出了在执行1/0之后出错了，运用日志，我们可以定位到那些没有导致程序终止，但是导致程序异常的bug。  
上面的例子比较简单，但是logging模块远比它强大，通过合理地配置模块logging，可以让日志实现下面的功能：
+ 记录不同级别的日志（DEBUG、INFO、WARNING、ERROR和CRITICAL以及自定义类型等）。默认情况下，只记录WARNING。（所以在上面代码里显式地设置level是logging.INFO）
+ 只记录与程序特定部分相关的条目
+ 记录有关时间、日期等方面的信息
+ 记录到其他位置，如文件、套接字
+ 配置logger，将一些或大部分日志过滤掉，这样无需重写程序就能获得所需的日志信息。

## 19.6 如果你已经不胜其烦
编写简单的程序的时候，一般不太需要测试框架、日志以及配置文件。但是，要考虑这些东西在将来是否会被需要，
比如，在重构项目的时候，就要考虑，这里是不是要做成可配置化的，是不是需要完整的测试套件等。
