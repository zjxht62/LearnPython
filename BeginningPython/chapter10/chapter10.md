# 第10章 开箱即用
## 10.1 模块
使用import可以导入外部模块
```python
import math
math.sin(0)
```
### 10.1.1 模块就是程序
任何Python程序都可以作为模块导入
```python
# hello.py
print('Hello, world!')
```
需要告诉解释器去哪里查找这个模块，可执行如下命令
```shell
>>> import sys
>>> sys.path.append('C:/python')
```
上面的命令告诉解释器，除了通常查找的位置之外，还应该到目录`C:\python`去查找这个模块，之后就
可以导入这个模块了
```shell
>>> import hello
Hello, world!
```
> 注意：当导入模块的时候，除了源代码的.py文件，还有一个名为__pycache__的子目录。这个里面包含的是
> 处理过的文件。Python能够更高效地处理他们，如果.py文件没有变化，那么导入模块的时候将导入处理后的文件，
> 否则将重新生成处理后的文件。

导入这个模块的时候会执行其中的代码。但是如果再次导入，什么事情都不会发生。
```shell
>>> import hello
```
因为模块并不是用来执行操作的，而是用来定义变量、函数、类等。鉴于定义只需要做一次，因此导入模块多次和导入一次的效果相同。
> 为何只导入一次
> 
> 如果两个模块彼此导入对方，就会出现无穷导入，如果第二次导入时什么都不会发生，这种循环将被打破。
> 
> 如果一定要重新加载模块，可使用模块importlib中的函数reload，它接受一个参数（要重新加载的模块），并返回重新加载的模块。如果在程序运行时修改了模块，并希望这种修改反映到程序中，这将很有用。

### 10.1.2 模块是用来下定义的
1. 在模块中定义函数  
```python
# 定义一个有函数的模块 
# hello2.py
def hello():
    print("Hello, world!")

# other.py
import hello2
hello2.hello()
```
通过模块，可以实现代码的重用，在多个程序中使用他们。

2. 在模块中添加测试代码  

由于模块在被导入的时候会被执行，所以需要进行特殊处理。
关键是检查模块是作为程序运行还是被导入到另一个程序。需要使用变量`__name__`
```shell
>>> __name__
'__main__'
>>> hello3.__name__
'hello3'
```
在主程序中（包括解释器的交互式提示符），变量__name__的值是'__main__'，而
在导入的模块中，这个变量被设置为该模块的名称。
```python
# 一个包含有条件地执行的测试代码的模块
# hello4.py
def hello():
    print('Hello, world!')

def test():
    hello()

if __name__ == '__main__':
    test()    
```
   