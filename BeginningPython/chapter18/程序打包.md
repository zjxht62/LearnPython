# 程序打包
Setuptools和较旧的Distutils都是用于发布Python包的工具包，让你能够使用Python轻松地编写安装脚本。
这些脚本可用于生成可发布的归档文档，供用户用来编译和安装你编写的库。  
下面主要介绍Setuptools。实际上，Setuptools不光用于创建基于脚本的Python安装程序，还可以用于编译扩展。
另外，通过将其与扩展py2exe和py2app结合起来使用，还能创建独立的Windows和macOS可执行程序。  
## 18.1 Setuptools基础  
通过编写简单的脚本，即可食用Setuptools完成多种任务。
```python
from setuptools import setup

setup(name='Hello',
      version='1.0',
      description='A simple example',
      author='zjx',
      py_modules=['hello'])
```
上面的参数不是固定的，可以什么都不传，参数的含义也很明显。创建脚本后，存储为setup.py，并确保同级目录中包括模块hello.py。  
如果直接运行`python setup.py`将输出如下内容：  
```shell
usage: setup.py [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: setup.py --help [cmd1 cmd2 ...]
   or: setup.py --help-commands
   or: setup.py cmd --help

error: no commands supplied
```
从上述输出可知，要获得更多的信息，可使用开关--help或--help-commands。尝试执行命令build，让Setuptools行动起来。  
`python setup.py build`  
输出如下：
```shell
running build
running build_py
creating build
creating build\lib
copying hello.py -> build\lib
```
Setuptools创建了一个名为build的目录，其中包含子目录lib。同时将hello.py复制到了lib中。
目录build相当于工作区，Setuptools在其中组装包（以及编译扩展库等）。安装时不需要执行命令build，
因为当执行install时，如果需要，命令build会自动执行。
> 注意 如果运行install，那么将会把hello.py复制到PYTHONPATH指定的特定目录中。但这只是咱们测试一下，所以应该找到它并删掉。
> 为此，要将安装位置记录下来；可以在setup.py的输出中找到。  
> 也可以使用开关-n，这样就只进行演示。

尝试安装一下：  
`$ python setup.py install`  
输出：
```text
running install
running bdist_egg
running egg_info
creating Hello.egg-info
writing Hello.egg-info\PKG-INFO
writing dependency_links to Hello.egg-info\dependency_links.txt
writing top-level names to Hello.egg-info\top_level.txt
writing manifest file 'Hello.egg-info\SOURCES.txt'
reading manifest file 'Hello.egg-info\SOURCES.txt'
writing manifest file 'Hello.egg-info\SOURCES.txt'
installing library code to build\bdist.win-amd64\egg
running install_lib
running build_py
creating build\bdist.win-amd64
creating build\bdist.win-amd64\egg
copying build\lib\hello.py -> build\bdist.win-amd64\egg
byte-compiling build\bdist.win-amd64\egg\hello.py to hello.cpython-38.pyc
creating build\bdist.win-amd64\egg\EGG-INFO
copying Hello.egg-info\PKG-INFO -> build\bdist.win-amd64\egg\EGG-INFO
copying Hello.egg-info\SOURCES.txt -> build\bdist.win-amd64\egg\EGG-INFO
copying Hello.egg-info\dependency_links.txt -> build\bdist.win-amd64\egg\EGG-INFO
copying Hello.egg-info\top_level.txt -> build\bdist.win-amd64\egg\EGG-INFO
zip_safe flag not set; analyzing archive contents...
creating dist
creating 'dist\Hello-1.0-py3.8.egg' and adding 'build\bdist.win-amd64\egg' to it
removing 'build\bdist.win-amd64\egg' (and everything under it)
Processing Hello-1.0-py3.8.egg
Copying Hello-1.0-py3.8.egg to c:\users\administrator\appdata\local\programs\python\python38\lib\site-packages
Adding Hello 1.0 to easy-install.pth file

Installed c:\users\administrator\appdata\local\programs\python\python38\lib\site-packages\hello-1.0-py3.8.egg
Processing dependencies for Hello==1.0
Finished processing dependencies for Hello==1.0
```
之后便可以使用模块hello了
```shell
>>> import hello
>>> hello.say_hello()
我是hello模块输出的内容
>>>
```
> 注意 如果运行的Python版本不是你安装的，并且你没有合适的权限，可能被禁止安装模块，因为你没有写入相应目录的权限。

这就是用于安装Python模块、包和扩展的标准机制。你只需提供一个小小的安装脚本即可。
如你所见，在安装过程中， Setuptools创建了一个.egg文件，这是一个独立的Python包。  
这里的例子只使用了py_modules。如果要安装整个包，可以用类似的方式（列出包名）使用指令packages。
你还可设置很多其他的选项。这些选项让你能够指定要安装什么以及安装到什么地方，等等。另外，编写好的脚本还可以和其他参数搭配，比如创建可发布的归档文件。 

## 18.2 打包